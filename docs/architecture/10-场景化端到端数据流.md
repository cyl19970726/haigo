# 10. åœºæ™¯åŒ–ç«¯åˆ°ç«¯æ•°æ®æµ

> æœ¬ç« ä¸ºè·¨å›¢é˜Ÿåä½œåŸºçº¿ï¼Œæè¿°ä¸åŒä¸šåŠ¡åœºæ™¯ä¸‹å‰ç«¯ (FE)ã€Move åˆçº¦ã€BFF ä»¥åŠå‘¨è¾¹æœåŠ¡ä¹‹é—´çš„æ•°æ®æµã€‚æ‰€æœ‰å›¾å‡ä½¿ç”¨åŒä¸€å›¾ä¾‹ï¼š
>
> - `FE`ï¼šapps/web å‰ç«¯åº”ç”¨
> - `Wallet`ï¼šAptos é’±åŒ…ï¼ˆPetra/Martian ç­‰ï¼‰
> - `Move`ï¼šé“¾ä¸Šåˆçº¦æ¨¡å—
> - `Indexer`ï¼šAptos Indexer GraphQL
> - `Fullnode`ï¼šAptos REST Fullnode API
> - `BFF`ï¼šapps/bff æœåŠ¡
> - `DB`ï¼šPostgresï¼ˆç» Prismaï¼‰
> - `Storage`ï¼šå¯¹è±¡å­˜å‚¨ / æœ¬åœ°åª’ä½“ç›®å½•
> - `Ops`ï¼šè¿è¥/åå°å·¥å…·

## 10.1 åœºæ™¯æ€»è§ˆ

| åœºæ™¯ç¼–å· | åç§° | è§¦å‘è§’è‰² | è¦†ç›–æ¨¡å— | ç°çŠ¶ |
|----------|------|----------|----------|------|
| R1 | å•†å®¶/ä»“åº“æ³¨å†Œäº‹ä»¶åŒæ­¥ | å•†å®¶ã€ä»“åº“ | registry | âœ… å·²å®ç° |
| R2 | æ¡£æ¡ˆå“ˆå¸Œæ ¡éªŒ | å•†å®¶ã€ä»“åº“ | registry | âœ… å·²å®ç° |
| W1 | å®¶åº­ä»“è´¨æŠ¼ä¸å­˜å‚¨è´¹è®¾ç½® | ä»“åº“ | staking | ğŸš§ è§„åˆ’ä¸­ |
| L1 | å®¶åº­ä»“ Listing é€‰æ‹© | å•†å®¶ | directory | âœ… å·²å®ç° |
| O1 | è®¢å•åˆ›å»ºä¸é“¾ä¸Šç­¾ç½² | å•†å®¶ | orders | âœ… åˆç‰ˆ |
| W2 | å®¶åº­ä»“è®¢å•æ”¶ä»¶ç®±ï¼ˆå¯è§æ€§ï¼‰ | ä»“åº“ | orders | ğŸš§ è§„åˆ’ä¸­ |
| O2 | ä»“å‚¨å‡ºåº“ä¸åª’ä½“ä¸Šä¼  | ä»“åº“ | orders + media | ğŸš§ è§„åˆ’ä¸­ |
| A1 | è¿æ¥é’±åŒ…ç™»å½•ï¼ˆç›´è¿ï¼‰ | å•†å®¶ã€ä»“åº“ | FE/Wallet (+å¯é€‰ BFF) | âœ… PoC |
| M1 | å•†å®¶è¯„ä»· | å•†å®¶ | reputation | ğŸš§ è§„åˆ’ä¸­ |

---

## 10.2 R1 â€” å•†å®¶/ä»“åº“æ³¨å†Œäº‹ä»¶åŒæ­¥ï¼ˆç°ç½‘ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE
  participant Wallet
  participant Move as Move::registry
  participant Indexer
  participant Fullnode
  participant BFF as BFF::Accounts
  participant DB as Postgres

  FE->>Wallet: æäº¤æ³¨å†Œè¡¨å• (address, profile hash, metadata)
  Wallet->>Move: register_* äº¤æ˜“ (ç­¾å)
  Move-->>Indexer: è®°å½• SellerRegistered / WarehouseRegistered äº‹ä»¶
  loop Polling
    BFF->>Indexer: GraphQL events(query by type & cursor)
    Indexer-->>BFF: äº‹ä»¶åˆ—è¡¨ (version, index, data)
    BFF->>Fullnode: GET /v1/transactions/by_version(version)
    Fullnode-->>BFF: äº¤æ˜“å“ˆå¸Œ & timestamp (è‹¥å¯ç”¨)
    BFF->>DB: Prisma upsert accounts (role, hash, txn_version...)
  end
  FE->>BFF: GET /api/accounts/:address
  BFF-->>FE: æ³¨å†Œèµ„æ–™ (æ¥è‡ª DB)
```

### R1 å®æ–½å‰ç½®ä¸å¸¸è§å‘ä½ï¼ˆé‡è¦ï¼‰
- ç¯å¢ƒå˜é‡å¿…é¡»ä¸€è‡´ä¸”æŒ‡å‘ Aptos Labs ç½‘å…³ï¼ˆé¿å…åŒ¿å 429ï¼‰ï¼š
  - `APTOS_INDEXER_URL=https://api.testnet.aptoslabs.com/v1/graphql`
  - `APTOS_NODE_API_URL=https://api.testnet.aptoslabs.com/v1`
  - å¯é€‰ï¼š`APTOS_NODE_API_KEY=aptoslabs_...`ï¼ˆBFF ä¼šåŒæ—¶é™„å¸¦ `Authorization: Bearer` ä¸ `x-aptos-api-key`ï¼‰
- æ¨¡å—åœ°å€å¿…é¡»æ­£ç¡®ï¼š
  - å‰ç«¯/åç«¯ç»Ÿä¸€ä»`.env.local`è¯»å– `NEXT_PUBLIC_APTOS_MODULE=0x<éƒ¨ç½²åœ°å€>`ï¼›BFF å°†ç”¨è¯¥åœ°å€æ‹¼æ¥äº‹ä»¶ç±»å‹ `${MODULE}::registry::SellerRegistered`/`WarehouseRegistered`ã€‚
- ç›‘å¬æ¸¸æ ‡ä¸é€Ÿç‡ï¼š
  - è‹¥ä»…éœ€è¦ä»æœ€æ–°å¼€å§‹ç›‘å¬ï¼š`ACCOUNT_INGESTOR_START_FROM_LATEST=true`ï¼ˆé»˜è®¤ï¼‰ï¼Œ`ACCOUNT_INGESTOR_BACKFILL_OFFSET_VERSIONS=0`ã€‚
  - è‹¥éœ€è¦å›å¡«ä¸€å°æ®µå†å²ï¼šæŠŠ `BACKFILL_OFFSET_VERSIONS` è®¾ä¸º 1e4 ä¹‹ç±»å°å€¼ï¼Œå¹¶é€‚å½“é™é€Ÿï¼š
    - `ACCOUNT_INGESTOR_INTERVAL_MS=60000`ã€`ACCOUNT_INGESTOR_PAGE_SIZE=10`ã€`ACCOUNT_INGESTOR_MAX_PAGES_PER_TICK=1`ã€‚
- æ—§äº§ç‰©ä¸å…¥å£ï¼š
  - BFF å¯åŠ¨è„šæœ¬å·²æŒ‡å‘ `dist/apps/bff/src/main.js`ï¼Œé¿å…åŠ è½½è¿‡æ—¶ `dist/main.js`ã€‚
- GraphQL å˜é‡ç±»å‹ï¼š
  - Indexer å¯¹ cursor ä½¿ç”¨ `bigint!`ï¼›BFF å·²æŒ‰å­—ç¬¦ä¸²ä¼ å‚è§„é¿ç±»å‹ä¸åŒ¹é…ã€‚

### R1 æˆåŠŸåé‡å®šå‘ï¼ˆæ–°å¢çº¦å®šï¼‰
- å½“é“¾ä¸Šäº¤æ˜“ç¡®è®¤ä¸” `/api/accounts/:address` è¿”å› 200ï¼Œå‰ç«¯åº”ï¼š
  - ç«‹åˆ»ä»¥æœ¬åœ°æ•°æ®ä¹è§‚æ›´æ–°æ³¨å†ŒçŠ¶æ€ï¼ˆå·²å®ç°ï¼‰ï¼Œå¹¶åœ¨éšåä¸€æ¬¡æ‹‰å–ä¸­ç”¨çœŸå®æ•°æ®è¦†ç›–ï¼ˆå·²å®ç°ï¼‰ã€‚
  - è‡ªåŠ¨æ ¹æ®è§’è‰²è·³è½¬åˆ°å„è‡ªå·¥ä½œå°ï¼š
    - å•†å®¶ï¼š`/dashboard/seller`
    - ä»“åº“ï¼š`/dashboard/warehouse`
  - è‹¥ 60 ç§’å†…ä»æœªä» BFF è¯»åˆ°èµ„æ–™ï¼ˆç›‘å¬å»¶è¿Ÿï¼‰ï¼Œä¿æŒå½“å‰é¡µé¢å¹¶ç»™å‡ºâ€œç¨ååˆ·æ–°â€çš„æç¤ºæŒ‰é’®ã€‚

## 10.3 R2 â€” æ¡£æ¡ˆå“ˆå¸Œæ ¡éªŒï¼ˆç°ç½‘ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE
  participant BFF as BFF::Accounts
  participant DB as Postgres

  FE->>BFF: POST /api/accounts/:address/verify-hash (multipart æ–‡ä»¶)
  BFF->>DB: æŸ¥è¯¢ accounts.profile_hash_value
  BFF->>BFF: ä½¿ç”¨ BLAKE3 è®¡ç®—ä¸Šä¼ æ–‡ä»¶å“ˆå¸Œ
  BFF-->>FE: è¿”å›åŒ¹é…ç»“æœ (200/400)
```

## 10.4 W1 å®¶åº­ä»“è´¨æŠ¼ä¸å­˜å‚¨è´¹è®¾ç½®ï¼ˆè§„åˆ’ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Warehouse Dashboard)
  participant BFF as BFF::Staking
  participant DB as Postgres
  participant Wallet
  participant Move as Move::staking
  participant Indexer
  participant Fullnode

  FE->>BFF: GET /api/staking/intent
  BFF-->>FE: è¿”å›æ‰€éœ€è´¨æŠ¼å‚æ•°ä¸å½“å‰è´¹ç‡ï¼ˆä¼˜å…ˆé“¾ä¸Šè§†å›¾ï¼‰
  FE->>Wallet: è°ƒç”¨ stake(amount) å¹¶ç­¾å
  Wallet->>Move: staking::stake
  Move-->>Indexer: StakeChanged äº‹ä»¶
  loop Polling
    BFF->>Indexer: æ‹‰å– StakeChanged
    Indexer-->>BFF: äº‹ä»¶æ•°æ®
    BFF->>Fullnode: ï¼ˆå…œåº•ï¼‰by_version è·å– txn hash/timestamp
    BFF->>DB: æ›´æ–° staking_positionsï¼ˆç¼“å­˜ï¼‰
  end
  FE->>Wallet: è°ƒç”¨ set_storage_fee å¹¶ç­¾å
  Wallet->>Move: set_storage_fee
  Move-->>Indexer: StorageFeeUpdated äº‹ä»¶
  loop Polling
    BFF->>Indexer: æ‹‰å– StorageFeeUpdated
    Indexer-->>BFF: äº‹ä»¶æ•°æ®
    BFF->>DB: æ›´æ–° storage_fees_cacheï¼ˆé“¾ä¸‹ç¼“å­˜ï¼Œå¯é€‰ï¼‰
  end
```

## 10.5 L1 å•†å®¶æµè§ˆå®¶åº­ä»“ Listingï¼ˆé€‰æ‹©ä»“ï¼‰ï¼ˆå·²å®ç°ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Warehouse Listing)
  participant BFF as BFF::Directory
  participant Cache as DirectoryCache
  participant Hasura
  participant DB as Postgres

  FE->>BFF: GET /api/warehouses?available=true&page=1&pageSize=12
  BFF->>Cache: å‘½ä¸­ 30s TTL ç¼“å­˜ï¼Ÿ
  alt ç¼“å­˜å‘½ä¸­
    Cache-->>BFF: è¿”å›ç¼“å­˜çš„èšåˆåˆ—è¡¨
  else ç¼“å­˜å¤±æ•ˆ
    BFF->>DB: SELECT accounts WHERE role='warehouse'
    BFF->>DB: SELECT staking_positions WHERE address IN [...]
    BFF->>DB: SELECT storage_fees_cache WHERE address IN [...]
    BFF->>Hasura: æŸ¥è¯¢ä»“åº“ç”»åƒï¼ˆè¯„åˆ†/æœåŠ¡åŒºåŸŸï¼Œå¯é€‰ï¼‰
    Hasura-->>BFF: è¿”å›è¡¥å……ç”»åƒ
    BFF->>Cache: å†™å…¥ TTL=30s çš„èšåˆç»“æœ
  end
  BFF-->>FE: è¿”å› { data: WarehouseSummary[], meta: { page, total, cacheHit } }
```

## 10.6 O1 â€” è®¢å•åˆ›å»ºä¸é“¾ä¸Šç­¾ç½²ï¼ˆåˆç‰ˆï¼‰

```mermaid
sequenceDiagram
  participant FE as FE
  participant BFF as BFF::Orders
  participant DB as Postgres
  participant Wallet
  participant Move as Move::orders
  participant Indexer
  participant Fullnode

  FE->>BFF: POST /api/orders/drafts (è‰ç¨¿ä¿å­˜)
  BFF->>DB: ä¿å­˜ draft (status=ORDER_DRAFT, payload)
  BFF-->>FE: è¿”å› recordUid + å¾…ç­¾å payload
  FE->>Wallet: è°ƒç”¨é’±åŒ…ç­¾å
  Wallet->>Move: create_order(recordUid, payload)
  Move-->>Indexer: è§¦å‘ OrderCreated äº‹ä»¶
  loop Polling
    BFF->>Indexer: GraphQL events(OrderCreated)
    Indexer-->>BFF: äº‹ä»¶åˆ—è¡¨
    BFF->>Fullnode: by_version è·å– hash/timestamp
    BFF->>DB: æ›´æ–° orders (status=ONCHAIN_CREATED, txn_hash...)
  end
  FE->>BFF: GET /api/orders/:recordUid
  BFF-->>FE: è¿”å›é“¾ä¸Š + é“¾ä¸‹æ±‡æ€»çŠ¶æ€
```

å®ç°çŠ¶æ€ï¼ˆåˆç‰ˆï¼‰ä¸ Anchorsï¼š
- BFFï¼ˆDirectoryï¼‰ï¼š`apps/bff/src/modules/directory/directory.module.ts`ã€`directory.controller.ts`ã€`directory.service.ts`ã€`directory.repository.ts`ã€`hasura.client.ts`ï¼ˆTTL ç¼“å­˜ã€Prismaï¼‹Hasura èšåˆã€æŒ‡æ ‡ `directory_request_total`/`directory_cache_hit_total`ï¼‰ã€‚
- FEï¼ˆç›®å½•ä½“éªŒï¼‰ï¼š`apps/web/features/directory/useWarehouseDirectory.ts`ã€`WarehouseFilters.tsx`ã€`WarehouseCard.tsx`ã€`app/(seller)/warehouses/page.tsx`ã€‚
- Dashboard å…¥å£ï¼š`apps/web/app/dashboard/seller/page.tsx` æ–°å¢ â€œBrowse directoryâ€ å¡ç‰‡ä¸²è” L1â†’O1ã€‚
- ä¸ O1 é›†æˆï¼š`CreateOrderView`ï¼ˆ`apps/web/features/orders/create/CreateOrderView.tsx`ï¼‰æ”¯æŒ `?warehouse=0x...` é¢„é€‰ CTA æ¥æºã€‚

å®ç°çŠ¶æ€ï¼ˆO1 åˆç‰ˆï¼‰ä¸ Anchorsï¼š
- BFFï¼š`apps/bff/src/modules/orders/orders.controller.ts`ï¼ˆPOST /api/orders/drafts, GET /api/orders, GET /api/orders/:recordUidï¼‰ã€`orders.service.ts`ã€`orders.repository.ts`ã€`orders-event-listener.service.ts`ï¼ˆIndexer è½®è¯¢ + Fullnode by_version å…œåº•ï¼‰ã€‚
- FEï¼š`apps/web/features/orders/useOrderDraft.ts`ï¼›`CreateOrderView` åœ¨ Review æ­¥éª¤åˆ›å»ºè‰ç¨¿å¹¶æ˜¾ç¤º `recordUid`ã€‚
- ç›‘æ§ï¼š`GET /metrics` æš´éœ² `order_listener_last_version`ï¼ˆgaugeï¼‰ã€`order_listener_error_total`ï¼ˆcounterï¼‰ä»¥åŠç›®å½•ç›¸å…³æŒ‡æ ‡ã€‚

## 10.7 å®¶åº­ä»“è®¢å•æ”¶ä»¶ç®±ï¼ˆå¯è§æ€§ï¼‰ï¼ˆè§„åˆ’ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Warehouse Orders)
  participant BFF as BFF::Orders
  participant DB as Postgres

  FE->>BFF: GET /api/orders?warehouse=0xWAREHOUSE
  BFF->>DB: æŸ¥è¯¢ orders (warehouse_address)
  DB-->>BFF: è®¢å•åˆ—è¡¨ï¼ˆå«æœ€æ–°çŠ¶æ€ï¼‰
  BFF-->>FE: æ˜¾ç¤ºå¾…å¤„ç†/åœ¨åº“/å·²å‡ºåº“è®¢å•
```

## 10.8 O2 â€” ä»“å‚¨å‡ºåº“ä¸åª’ä½“ä¸Šä¼ ï¼ˆè§„åˆ’ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Warehouse)
  participant BFF as BFF::Media
  participant Storage
  participant DB as Postgres
  participant Wallet
  participant Move as Move::orders
  participant Indexer

  FE->>BFF: POST /api/media/uploads (ç‰©æµç…§ç‰‡/è§†é¢‘)
  BFF->>Storage: ä¿å­˜æ–‡ä»¶ï¼Œç”Ÿæˆ mediaId + hash
  BFF->>DB: å†™å…¥ order_media_assets (mediaId, hash)
  BFF-->>FE: è¿”å› mediaId åˆ—è¡¨
  FE->>Wallet: è°ƒç”¨ check_out(recordUid, logisticsNo, mediaHashes)
  Wallet->>Move: æäº¤äº¤æ˜“
  Move-->>Indexer: OrderFulfilled / LogisticsUpdated äº‹ä»¶
  loop Polling
    BFF->>Indexer: æ‹‰å–å‡ºåº“ç›¸å…³äº‹ä»¶
    Indexer-->>BFF: äº‹ä»¶æ•°æ®
    BFF->>DB: æ ¡éªŒå¹¶æ›´æ–° orders çŠ¶æ€ã€ç‰©æµä¿¡æ¯
  end
  FE->>BFF: GET /api/orders/:recordUid/timeline
  BFF-->>FE: è¿”å›çŠ¶æ€æ—¶é—´çº¿ + åª’ä½“èµ„æº
```

### 10.5.1 ç›®æ ‡ä¸äº¤ä»˜ç‰©
- FE ä»“å‚¨å‡ºåº“é¡µé¢ï¼šæ”¯æŒå¤šåª’ä½“ä¸Šä¼ ï¼ˆå›¾ç‰‡/è§†é¢‘ï¼‰ã€ç‰©æµä¿¡æ¯å¡«å†™ï¼Œç­¾åæäº¤ `orders::check_out`ï¼Œå¹¶å±•ç¤ºâ€œè®¢å•æ—¶é—´çº¿ + åª’ä½“â€èšåˆè§†å›¾ã€‚
- BFF åª’ä½“ä¸Šä¼ æ²¿ç”¨ç°æœ‰ `MediaService`ï¼›æ–°å¢å‡ºå…¥åº“äº‹ä»¶ç›‘å¬å™¨ï¼Œè½åº“æ—¶é—´çº¿ä¸çŠ¶æ€ï¼›æä¾› `/timeline` èšåˆæ¥å£ï¼›Fullnode by_version å…œåº•äº‹åŠ¡å“ˆå¸Œä¸æ—¶é—´æˆ³ã€‚
- DB å¤ç”¨ `orders`ã€`order_events`ã€`media_assets` ä¸‰è¡¨ï¼Œé€šè¿‡ `record_uid` ä¸åª’ä½“å“ˆå¸Œè¿›è¡Œå¯¹è´¦ï¼›ç‰©æµä¿¡æ¯å­˜å…¥ `order_events.data`ï¼ˆé¿å…é¢å¤–è¿ç§»ï¼‰ã€‚
- æµ‹è¯•è¦†ç›–ï¼šåª’ä½“å“ˆå¸Œä¸€è‡´æ€§ã€äº‹ä»¶â†’æ—¶é—´çº¿æ˜ å°„ã€Fullnode å…œåº•ã€æ¥å£å¥‘çº¦ã€å‰ç«¯äº¤äº’ã€‚

### 10.5.2 è·¨å±‚è®¾è®¡ï¼ˆå¥‘çº¦ä¸æµç¨‹ï¼‰
- FE
  - ä¸Šä¼ ï¼š`POST /api/media/uploads` è¿”å› `{ recordUid, stage, category, hash.value }`ï¼›FE å°†è¿”å›çš„ `hash.value` æ”¶é›†ä¸º `mediaHashes`ã€‚
  - å‡ºåº“ç­¾åï¼šè°ƒç”¨é’±åŒ…æ‰§è¡Œ `orders::check_out(order_id, logistics, media_hashes)`ï¼›éšåè½®è¯¢ `GET /api/orders/:recordUid` æˆ– `GET /api/orders/:recordUid/timeline` åˆ·æ–°çŠ¶æ€ã€‚
- BFF
  - ç›‘å¬ Indexer äº‹ä»¶ï¼š`CheckedIn`ã€`SetInStorage`ã€`CheckedOut`ï¼Œæ¯æ¡äº‹ä»¶åœ¨å†™å…¥ `order_events` å‰è°ƒç”¨ Fullnode `by_version` å…œåº• `txn_hash/timestamp`ã€‚
  - äº‹ä»¶å…¥åº“åï¼Œ`OrdersRepository` æ›´æ–° `orders.status` ä¸æ—¶é—´çº¿ï¼›æŒ‰ `media_hashes[]` å…³è” `media_assets.hash_value`ï¼Œæ ‡è®° `matched_offchain=true`ã€‚
  - æä¾› `GET /api/orders/:recordUid`ï¼ˆè¯¦æƒ…å«æ—¶é—´çº¿æ‘˜è¦ï¼‰ä¸ `GET /api/orders/:recordUid/timeline`ï¼ˆä»…æ—¶é—´çº¿ + åª’ä½“ï¼‰ã€‚
- Moveï¼ˆå‚è€ƒ 3.4ï¼‰
  - `orders::check_in` â†’ `CheckedIn` äº‹ä»¶ï¼›`orders::set_in_storage` â†’ `SetInStorage`ï¼›`orders::check_out` â†’ `CheckedOut`ã€‚
  - å†…éƒ¨ `assert_hash_valid` é™åˆ¶ 32 å­—èŠ‚ BLAKE3ï¼ˆä¸é“¾ä¸‹ `MediaService` è®¡ç®—ä¸€è‡´ï¼‰ã€‚

### 10.5.3 æ ¸å¿ƒ Anchor ä¸ä»£ç éª¨æ¶

1) äº‹ä»¶ç›‘å¬å™¨ï¼ˆBFFï¼‰

æ–‡ä»¶ï¼š`apps/bff/src/modules/orders/orders-fulfillment-listener.service.ts`ï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰
```ts
import { Injectable, Logger, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { OrdersService } from './orders.service.js';
import { ORDERS_MODULE_ADDRESS, ORDERS_MODULE_NAME } from '@haigo/shared/config/aptos';

type EventRow = { transaction_version: string; event_index: number; type: string; data: any };

const QUERY = /* GraphQL */ `
  query Events($eventType: String!, $limit: Int!, $cursorVersion: bigint!, $cursorEventIndex: bigint!) {
    events(
      where: {
        type: { _eq: $eventType }
        _or: [
          { transaction_version: { _gt: $cursorVersion } },
          { transaction_version: { _eq: $cursorVersion }, event_index: { _gt: $cursorEventIndex } }
        ]
      }
      order_by: [{ transaction_version: asc }, { event_index: asc }]
      limit: $limit
    ) { transaction_version event_index type data }
  }
`;

@Injectable()
export class OrdersFulfillmentListener implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(OrdersFulfillmentListener.name);
  private poll?: NodeJS.Timeout;
  private lastV = BigInt(-1);
  private lastI = BigInt(-1);
  constructor(private cfg: ConfigService, private orders: OrdersService) {}
  async onModuleInit() { await this.pollOnce(); this.poll = setInterval(() => void this.pollOnce(), Number(this.cfg.get('ingestion.pollingIntervalMs', 30_000))); }
  async onModuleDestroy() { if (this.poll) clearInterval(this.poll); }

  private async pollOnce() {
    const types = ['CheckedIn', 'SetInStorage', 'CheckedOut'] as const;
    for (const t of types) await this.pullType(t);
  }

  private async pullType(kind: (typeof ORDER_EVENT_TYPES)[number]) {
    const eventType = `${ORDERS_MODULE_ADDRESS}::${ORDERS_MODULE_NAME}::${kind}`;
    const rows = await this.fetch(eventType);
    for (const e of rows) await this.process(kind, e);
  }

  private async fetch(eventType: string): Promise<EventRow[]> { /* åŒ O1ï¼šPOST Indexer GraphQLï¼Œæºå¸¦ API keyï¼Œå¯å¤ç”¨å·¥å…· */ return []; }

  private async process(kind: 'CheckedIn'|'SetInStorage'|'CheckedOut', evt: EventRow) {
    const meta = await this.resolveTxnMetaByVersion(evt.transaction_version);
    const d = evt.data ?? {};
    const orderId = Number.parseInt(d.order_id ?? d.orderId ?? '0', 10);
    if (kind === 'CheckedIn') {
      await this.orders.applyCheckedInEvent({
        txnVersion: BigInt(evt.transaction_version), eventIndex: BigInt(evt.event_index),
        txnHash: meta?.hash, chainTimestamp: meta?.timestamp,
        orderId, warehouse: String(d.warehouse ?? ''), mediaHashes: (d.media_hashes ?? d.mediaHashes ?? []) as string[]
      });
    } else if (kind === 'SetInStorage') {
      await this.orders.applySetInStorageEvent({
        txnVersion: BigInt(evt.transaction_version), eventIndex: BigInt(evt.event_index),
        txnHash: meta?.hash, chainTimestamp: meta?.timestamp, orderId
      });
    } else if (kind === 'CheckedOut') {
      await this.orders.applyCheckedOutEvent({
        txnVersion: BigInt(evt.transaction_version), eventIndex: BigInt(evt.event_index),
        txnHash: meta?.hash, chainTimestamp: meta?.timestamp,
        orderId, logistics: d.logistics ?? d.logistics_outbound ?? {}, mediaHashes: (d.media_hashes ?? d.mediaHashes ?? []) as string[]
      });
    }
    this.lastV = BigInt(evt.transaction_version); this.lastI = BigInt(evt.event_index);
  }

  private async resolveTxnMetaByVersion(version: string) {/* å‚è€ƒ O1: by_version å…œåº• */ return null; }
}
```

2) è®¢å•ä»“å‚¨ä»“äº‹ä»¶å…¥åº“ï¼ˆBFFï¼‰

æ–‡ä»¶ï¼š`apps/bff/src/modules/orders/orders.service.ts`ï¼ˆè¿½åŠ æ–¹æ³•ï¼‰
```ts
async applyCheckedInEvent(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; warehouse: string; mediaHashes: string[]; }): Promise<void> {
  await this.repo.upsertCheckedIn(evt);
}
async applySetInStorageEvent(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; }): Promise<void> {
  await this.repo.upsertSetInStorage(evt);
}
async applyCheckedOutEvent(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; logistics?: any; mediaHashes: string[]; }): Promise<void> {
  await this.repo.upsertCheckedOut(evt);
}
```

æ–‡ä»¶ï¼š`apps/bff/src/modules/orders/orders.repository.ts`ï¼ˆè¿½åŠ æ–¹æ³•éª¨æ¶ï¼‰
```ts
async upsertCheckedIn(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; warehouse?: string; mediaHashes: string[]; }) {
  const recordUid = deriveRecordUid(evt.orderId, evt.txnHash ?? undefined);
  // 1) è®¢å•çŠ¶æ€
  await this.prisma.order.upsert({
    where: { recordUid },
    create: { recordUid, status: 'WAREHOUSE_IN' as any, orderId: evt.orderId, txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null },
    update: { status: 'WAREHOUSE_IN' as any, txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null }
  });
  // 2) äº‹ä»¶è¡¨
  await this.prisma.orderEvent.upsert({
    where: { txnVersion_eventIndex: { txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any } },
    create: { recordUid, orderId: evt.orderId, type: 'CheckedIn', txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null, data: { media_hashes: evt.mediaHashes } },
    update: {}
  });
  // 3) åª’ä½“å¯¹è´¦ï¼šæŒ‰ hash_value åŒ¹é…å¹¶æ ‡è®° matched_offchain=true
  if (evt.mediaHashes?.length) {
    await this.prisma.mediaAsset.updateMany({ where: { recordUid, hashValue: { in: evt.mediaHashes.map((h) => h.replace(/^0x/, '').toLowerCase()) } }, data: { matchedOffchain: true } });
  }
}

async upsertSetInStorage(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; }) {
  const recordUid = deriveRecordUid(evt.orderId, evt.txnHash ?? undefined);
  await this.prisma.order.update({ where: { recordUid }, data: { status: 'IN_STORAGE' as any, txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null } });
  await this.prisma.orderEvent.upsert({ where: { txnVersion_eventIndex: { txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any } }, create: { recordUid, orderId: evt.orderId, type: 'SetInStorage', txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null }, update: {} });
}

async upsertCheckedOut(evt: { txnVersion: bigint; eventIndex: bigint; txnHash?: string|null; chainTimestamp?: Date|null; orderId: number; logistics?: any; mediaHashes: string[]; }) {
  const recordUid = deriveRecordUid(evt.orderId, evt.txnHash ?? undefined);
  await this.prisma.order.update({ where: { recordUid }, data: { status: 'WAREHOUSE_OUT' as any, txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null } });
  await this.prisma.orderEvent.upsert({ where: { txnVersion_eventIndex: { txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any } }, create: { recordUid, orderId: evt.orderId, type: 'CheckedOut', txnVersion: evt.txnVersion as any, eventIndex: evt.eventIndex as any, txnHash: evt.txnHash ?? null, chainTimestamp: evt.chainTimestamp ?? null, data: { logistics: evt.logistics ?? null, media_hashes: evt.mediaHashes } }, update: {} });
  if (evt.mediaHashes?.length) {
    await this.prisma.mediaAsset.updateMany({ where: { recordUid, hashValue: { in: evt.mediaHashes.map((h) => h.replace(/^0x/, '').toLowerCase()) } }, data: { matchedOffchain: true } });
  }
}
```

3) æ—¶é—´çº¿èšåˆï¼ˆBFFï¼‰

æ–‡ä»¶ï¼š`apps/bff/src/modules/orders/orders.service.ts`ï¼ˆæˆ– `orders.timeline.service.ts` æœªæ¥ç›®æ ‡è·¯å¾„ï¼‰
```ts
async getTimeline(recordUid: string) {
  // æ±‡æ€» order_events ä¸ media_assetsï¼ŒæŒ‰ txnVersion/occurredAt å‡åº
  // æ˜ å°„ç±»å‹ â†’ é˜¶æ®µï¼šOrderCreatedâ†’CREATED, CheckedInâ†’WAREHOUSE_IN, SetInStorageâ†’IN_STORAGE, CheckedOutâ†’WAREHOUSE_OUT
}
```

æ§åˆ¶å™¨è¿½åŠ ï¼š`apps/bff/src/modules/orders/orders.controller.ts`
```ts
@Get(':recordUid/timeline')
async timeline(@Param('recordUid') recordUid: string) { return this.orders.getTimeline(recordUid); }
```

4) FE å‡ºåº“é¡µé¢ä¸ Hookï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰

- é¡µé¢å…¥å£ï¼š`apps/web/app/(warehouse)/orders/[recordUid]/outbound/page.tsx`
- Hookï¼š`apps/web/features/orders/outbound/useOutboundForm.ts`
```ts
'use client';
import { useState, useCallback } from 'react';
import { uploadOrderMedia } from '@/app/lib/api/media';
import { useWalletContext } from '@/app/lib/wallet/context';

export function useOutboundForm(recordUid: string) {
  const { signAndSubmitTransaction, networkStatus } = useWalletContext();
  const [mediaHashes, setMediaHashes] = useState<string[]>([]);
  const [logistics, setLogistics] = useState<{ carrier?: string; trackingNumber?: string; notes?: string }>({});

  const uploadFiles = useCallback(async (files: File[]) => {
    const hashes: string[] = [];
    for (const file of files) {
      const { data } = await uploadOrderMedia({ file, recordUid, stage: 'outbound' });
      hashes.push(data.hash.value);
    }
    setMediaHashes((prev) => Array.from(new Set([...prev, ...hashes])));
  }, [recordUid]);

  const signCheckOut = useCallback(async (orderId: number) => {
    const tx = { /* æ„å»º orders::check_out è¾“å…¥ï¼ˆæŒ‰ç½‘ç»œï¼‰ */ };
    return signAndSubmitTransaction(tx);
  }, [signAndSubmitTransaction, networkStatus.expected, logistics, mediaHashes]);

  return { mediaHashes, logistics, setLogistics, uploadFiles, signCheckOut };
}
```

æ³¨æ„ï¼š`MediaService.resolveCategory` éœ€æŒ‰ `stage` å‰ç¼€ç”Ÿæˆ `outbound_photo/video/document`ï¼ˆç°å®ç°é»˜è®¤ä¸º inbound_*ï¼Œåç»­æ”¹é€ æ—¶ä¸€å¹¶æäº¤ï¼‰ã€‚

### 10.5.4 å®æ–½æ­¥éª¤
1. BFF ç›‘å¬
   - æ–°å¢ `OrdersFulfillmentListener` å¹¶æŒ‚è½½åˆ° `OrdersModule`ï¼ŒæŒ‰ O1 ç›‘å¬å™¨å®ç° GraphQL è°ƒç”¨ä¸ Fullnode å…œåº•ã€‚
2. Repository/Service
   - åœ¨ `OrdersRepository/OrdersService` ä¸­è¡¥é½ `CheckedIn/SetInStorage/CheckedOut` ä¸‰ä¸ª upsert æ–¹æ³•ä¸èšåˆ `getTimeline`ã€‚
3. æ¥å£ä¸å‰ç«¯
   - æ–°å¢ `GET /api/orders/:recordUid/timeline`ï¼›å‰ç«¯ Outbound é¡µå¯¹æ¥ä¸Šä¼ ä¸ç­¾åé€»è¾‘ï¼Œæ—¶é—´çº¿æ¶ˆè´¹è¯¥æ¥å£ã€‚
4. è§‚æµ‹ä¸è¡¥å¿
   - ç»§æ‰¿ O1 æŒ‡æ ‡ä¸è¡¥å¿ç­–ç•¥ï¼šäº‹ä»¶æ¸¸æ ‡ã€Fullnode å¤±è´¥è®¡æ•°ã€åª’ä½“å¯¹è´¦å¤±è´¥é‡è¯•é˜Ÿåˆ—ã€‚

### 10.5.5 æµ‹è¯•è®¡åˆ’
- å•å…ƒæµ‹è¯•
  - `orders.repository.spec.ts`ï¼šä¸‰ç±»äº‹ä»¶ upsert å¹‚ç­‰ï¼›åª’ä½“å“ˆå¸Œå¯¹è´¦ï¼ˆmatched_offchain æ ‡è¯†ï¼‰ã€‚
  - `orders-fulfillment-listener.spec.ts`ï¼šä¸‰ç±»äº‹ä»¶æŒ‰æ¸¸æ ‡æ¨è¿›ï¼›Fullnode by_version 404 åˆ†æ”¯è®°å½•å‘Šè­¦ä½†ä¸é˜»å¡ã€‚
- é›†æˆæµ‹è¯•
  - `GET /api/orders/:recordUid/timeline` è¿”å›é˜¶æ®µæ˜ å°„ä¸åª’ä½“åˆ—è¡¨ï¼›ç­¾åå 30s å†…å‡ºç° `CheckedOut` èŠ‚ç‚¹ã€‚
- å‰ç«¯æµ‹è¯•
  - `useOutboundForm.test.tsx`ï¼šå¤šæ–‡ä»¶ä¸Šä¼  â†’ æ”¶é›†åª’ä½“å“ˆå¸Œï¼›ç­¾åè°ƒç”¨å‚æ•°æ„é€ æ­£ç¡®ï¼›å‡ºé”™æç¤ºï¼ˆç½‘ç»œ/æ‹’ç­¾/å“ˆå¸Œä¸åŒ¹é…ï¼‰ã€‚

### 10.5.6 éªŒæ”¶æ ‡å‡†ï¼ˆAcceptanceï¼‰
- ä»“åº“å¯åœ¨é¡µé¢å®Œæˆåª’ä½“ä¸Šä¼ ä¸ `check_out` ç­¾åï¼›
- BFF åœ¨ 30s å†…å°† `CheckedIn/SetInStorage/CheckedOut` æ˜ å°„ä¸ºæ—¶é—´çº¿èŠ‚ç‚¹å¹¶æ›´æ–° `orders.status`ï¼›
- `media_assets.hash_value` ä¸é“¾ä¸Š `media_hashes[]` å¯¹è´¦ä¸€è‡´ï¼Œå¹¶æ ‡è®° `matched_offchain`ï¼›
- Fullnode ç¼ºå¤±äº‹åŠ¡å…ƒæ•°æ®æ—¶ï¼Œé€šè¿‡ `by_version` å…œåº•ï¼›
- æ—¥å¿—ã€æŒ‡æ ‡ã€å‘Šè­¦å®Œå¤‡ï¼Œæ¥å£å¥‘çº¦ä¸æ–‡æ¡£ä¸€è‡´ã€‚

### 10.5.7 ç›¸å…³æ–‡æ¡£é˜…è¯»æ¸…å•ï¼ˆå¿…è¯»ï¼‰
- ç³»ç»Ÿåˆ†å±‚æ¦‚è§ˆï¼š`docs/architecture/2-ç³»ç»Ÿåˆ†å±‚æ¦‚è§ˆ.md:1`
- é“¾ä¸Šåˆçº¦ O2ï¼š`docs/architecture/3-é“¾ä¸Šåˆçº¦è®¾è®¡.md:167`
- é“¾ä¸‹æœåŠ¡ O2ï¼š`docs/architecture/4-é“¾ä¸‹æœåŠ¡ä¸æ•°æ®æµ.md:169`
- Fullnode å…œåº•è®¾è®¡ï¼š`docs/architecture/4-é“¾ä¸‹æœåŠ¡ä¸æ•°æ®æµ.md:143`
- å‰ç«¯ Anchorï¼ˆO2ï¼‰ï¼š`docs/architecture/5-å‰ç«¯ä½“éªŒ.md:166`
- éƒ¨ç½²ä¸è¿è¡Œï¼ˆEpic 2 ç»„ä»¶ï¼‰ï¼š`docs/architecture/6-éƒ¨ç½²ä¸ç¯å¢ƒ.md:184`
- åª’ä½“å­˜å‚¨ï¼ˆStory 2.3ï¼‰ï¼š`docs/architecture/6-éƒ¨ç½²ä¸ç¯å¢ƒ.md:245`
- è®¢å•ç´¢å¼•ä¸ç›‘æ§ï¼ˆStory 2.4ï¼‰ï¼š`docs/architecture/6-éƒ¨ç½²ä¸ç¯å¢ƒ.md:252`

<!-- 10.12 / 10.13 æš‚æ—¶ç§»é™¤ï¼ˆæŒ‰è®¨è®ºï¼‰ -->

## 10.9 å•†å®¶è¯„ä»·ï¼ˆè§„åˆ’ï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Merchant Reviews)
  participant BFF as BFF::Reputation
  participant DB as Postgres

  FE->>BFF: POST /api/reviews {orderUid, rating, comment}
  BFF->>DB: ä¿å­˜è¯„ä»·ï¼ˆä¸ä»“åº“èšåˆå±•ç¤ºï¼‰
  BFF-->>FE: æˆåŠŸ
```

> è¯´æ˜ï¼šæš‚ä¸è€ƒè™‘ slash ç›¸å…³çš„æƒ©ç½šé€»è¾‘ï¼Œåç»­åœ¨å£°èª‰/è´¨æŠ¼æ¨¡å—æ¼”è¿›æ—¶å†è¡¥å……é“¾ä¸Š/é“¾ä¸‹è”åŠ¨ã€‚

## 10.10 è¡¥å¿ä¸ç›‘æ§

- æ‰€æœ‰ç›‘å¬å™¨å¿…é¡»ç»´æŠ¤ `transaction_version + event_index` æ¸¸æ ‡ï¼Œæ”¯æŒå¹‚ç­‰é‡æ”¾ã€‚
- å½“ Indexer ç¼ºå¤±å“ˆå¸Œæˆ–æ—¶é—´æˆ³æ—¶ï¼Œç»Ÿä¸€ä½¿ç”¨ Fullnode REST `by_version` å…œåº•ã€‚
- å»ºç«‹åå°ä»»åŠ¡æ¸…ç†å­¤å„¿åª’ä½“ã€è¡¥é½ç¼ºå¤±å“ˆå¸Œã€å¯¹è´¦é“¾ä¸Šé“¾ä¸‹å·®å¼‚ã€‚
- ç›‘æ§æŒ‡æ ‡ï¼šäº‹ä»¶å»¶è¿Ÿã€REST é‡è¯•æ¬¡æ•°ã€API é”™è¯¯ç‡ã€å­˜å‚¨å®¹é‡ã€è¡¥å¿é˜Ÿåˆ—ç§¯å‹ã€‚
- æ–°å¢åœºæ™¯éœ€åŒæ­¥æ›´æ–°æœ¬æ–‡ä»¶åŠç›¸å…³æ¶æ„/æµç¨‹æ–‡æ¡£ï¼Œä¿æŒä¸‰ç«¯ä¸€è‡´ã€‚

## 10.11 åœºæ™¯åŒ– Anchor è®¾è®¡ä¸ä»»åŠ¡æ‹†åˆ†

ä¸ºç¡®ä¿ä»£ç é”šç‚¹ (Anchor) ä¸æ•°æ®æµä¿æŒä¸€è‡´ï¼Œåç»­å¼€å‘å°†ä»¥æœ¬ç« å„åœºæ™¯ä¸ºå•ä½æ‹†åˆ†ä»»åŠ¡ã€‚æ¯ä¸ªåœºæ™¯åŒ…å«ä¸‰ç±» Anchorï¼š

- **FE Anchor**ï¼šå‰ç«¯é¡µé¢ã€Hookã€çŠ¶æ€æˆ– UI ç»„ä»¶é”šç‚¹
- **BFF Anchor**ï¼šNestJS æ¨¡å—ã€æœåŠ¡ã€ç›‘å¬å™¨ã€DTO/Schema
- **Move Anchor**ï¼šåˆçº¦å‡½æ•°ã€äº‹ä»¶ã€å­˜å‚¨ç»“æ„

| åœºæ™¯ | FE Anchors | BFF Anchors | Move Anchors | æ•°æ®å­˜å‚¨/å¤–éƒ¨ä¾èµ– |
|------|------------|-------------|--------------|-------------------|
| **R1 æ³¨å†Œäº‹ä»¶åŒæ­¥** | `apps/web/features/registration/RegisterView.tsx` æ³¨å†Œæµç¨‹ / `useRegistrationForm` | `AccountsEventListener`ã€`AccountsService`ã€`AccountsRepository`ã€`@haigo/bff` é…ç½® (`indexerUrl`, `nodeApiUrl`) | `registry::register_seller` / `registry::register_warehouse` äº¤æ˜“ & `SellerRegistered`/`WarehouseRegistered` äº‹ä»¶ | Postgres `accounts` è¡¨ï¼›Fullnode REST by_version |
| **R2 æ¡£æ¡ˆå“ˆå¸Œæ ¡éªŒ** | `RegistrationHashVerifier` ç»„ä»¶ / `useVerifyHash` Hook | `/api/accounts/:address/verify-hash` æ§åˆ¶å™¨ã€`HashVerifierService` | ï¼ˆæ— æ–°åˆçº¦ï¼›ä½¿ç”¨é“¾ä¸Šå·²æœ‰å“ˆå¸Œä½œä¸ºå¯¹ç…§ï¼‰ | Postgres `accounts.profile_hash_value`; ä¸´æ—¶æ–‡ä»¶å†…å­˜å­˜å‚¨ |
| **O1 è®¢å•åˆ›å»ºç­¾ç½²** | è®¢å•è‰ç¨¿é¡µ `CreateOrderView`ã€`useOrderDraft` Hookã€ä¸‹å•ç¡®è®¤æ¨¡æ€ | `OrdersDraftController`ã€`OrdersEventListener`ã€`OrdersService`ã€Prisma `Order` Model | `orders::create_order` å‡½æ•°ã€`OrderCreated` äº‹ä»¶ | Postgres `orders` è¡¨ï¼›Fullnode REST by_version |
| **O2 ä»“å‚¨å‡ºåº“ + åª’ä½“ä¸Šä¼ ** | ä»“å‚¨å‡ºåº“é¡µ `OrderCheckOutView`ã€`useOutboundForm`ã€åª’ä½“ä¸Šä¼ ç»„ä»¶ | `MediaUploadController`ã€`MediaStorageService`ã€`OrderFulfillmentListener`ã€`OrdersTimelineService` | `orders::check_out` / `orders::update_logistics`ã€`OrderFulfilled`/`LogisticsUpdated` äº‹ä»¶ | Postgres `order_media_assets`ã€`orders` è¡¨ï¼›å¯¹è±¡å­˜å‚¨/æœ¬åœ°ç£ç›˜ |
| **C1 ç†èµ”å¼€å¯/ç»“æ¡ˆ** | ç†èµ”é¡µé¢ `ClaimWorkflow`ã€`ClaimForm`, `ClaimTimeline` | `ClaimsController`ã€`ClaimsService`ã€`ClaimEventListener`ã€èµ”ä»˜é£æ§ä»»åŠ¡ | `insurance::open_claim` / `insurance::resolve_claim`ã€`ClaimOpened`/`ClaimResolved` äº‹ä»¶ | Postgres `claims`ï¼ˆå« evidencesï¼‰ã€åª’ä½“å­˜å‚¨ï¼›è¿è¥é€šçŸ¥æ¸ é“ |
| **S1 è´¨æŠ¼ä¸ä¿¡ç”¨è¯„åˆ†** | è´¨æŠ¼é¢æ¿ `StakingDashboard`ã€`useStakingSummary`ã€ä¿¡ç”¨æ¦œ `CreditLeaderboard` | `StakingController`ã€`StakingEventListener`ã€`CreditScoreService`ã€æ‰¹å¤„ç†ä»»åŠ¡ | `staking::stake` / `staking::unstake`ã€`StakeChanged` äº‹ä»¶ï¼›ä¿¡ç”¨åˆçº¦äº‹ä»¶ | Postgres `staking_positions`ã€`credit_scores`ï¼›Fullnode REST ä½™é¢æŸ¥è¯¢ï¼›åˆ†æä»»åŠ¡/æ¶ˆæ¯é˜Ÿåˆ— |

> **ä»»åŠ¡æ‹†åˆ†è§„åˆ™**ï¼š
> - åç»­å¼€å‘æŒ‰åœºæ™¯æ‹†åˆ† Storyï¼Œå¦‚ â€œR1.2 æ”¯æŒ Fullnode å“ˆå¸Œè¡¥é½â€ã€â€œO2.1 åª’ä½“ä¸Šä¼  APIâ€ ç­‰ã€‚
> - æ¯ä¸ª Story åœ¨å®Œæˆæ—¶éœ€æ›´æ–°æœ¬è¡¨ä¸­å¯¹åº” Anchor çš„å®ç°çŠ¶æ€ï¼Œå¹¶è¡¥å……æµ‹è¯•/ç›‘æ§ã€‚
> - è‹¥å¼•å…¥æ–°çš„åœºæ™¯æˆ– Anchorï¼Œé¡»å…ˆæ›´æ–°æœ¬åˆ—è¡¨å†å¼€å§‹å¼€å‘ã€‚
## 10.0 A1 â€” è¿æ¥é’±åŒ…ç™»å½•ï¼ˆPoCï¼‰

```mermaid
sequenceDiagram
  participant FE as FE (Landing)
  participant Wallet
  participant BFF as BFF (optional)

  FE->>Wallet: Connect request
  Wallet-->>FE: Address/PublicKey/Network
  alt Registered
    FE->>FE: Redirect to /dashboard/{role}
  else Not registered
    FE->>FE: Deep link to /register
  end

  opt Session (optional, later)
    FE->>BFF: GET /auth/nonce
    BFF-->>FE: nonce
    FE->>Wallet: Sign nonce
    Wallet-->>FE: Signature
    FE->>BFF: POST /auth/verify {address, signature}
    BFF-->>FE: Set-Cookie session
  end
```

è¯´æ˜ï¼š
- å½“å‰ PoC ä¸ä¾èµ–åç«¯ä¼šè¯ï¼ŒæŒ‰è¿æ¥é’±åŒ…å³å¯è¿›å…¥ï¼ˆå—ç½‘ç»œ/è§’è‰²åˆ¤æ–­çº¦æŸï¼‰ã€‚
- åç»­ï¼ˆA2ï¼‰å¯æŒ‰â€œæŒ‘æˆ˜-ç­¾å-æ¢ä¼šè¯â€æ¨¡å¼æ¥å…¥æœ€å°åç«¯ç™»å½•ã€‚
