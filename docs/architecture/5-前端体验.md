# 5. 前端体验

> 前端架构以 Next.js App Router（`apps/web`）为核心，围绕《10-场景化端到端数据流》拆分页面与 Hook。以下 Anchor 覆盖现网注册流程（R1/R2）以及订单、理赔、质押等规划特性，所有新页面必须先在本章节登记 Anchor 与核心代码片段。

## 5.1 模块锚点索引
| 区域 | Anchor | 实施状态 | 场景 |
|------|--------|----------|------|
| 全局 Provider | `apps/web/app/providers.tsx:1` | ✅ | 全部 |
| Wallet 上下文 | `apps/web/lib/wallet/context.tsx:1` | ✅ | 全部 |
| NetworkGuard | `apps/web/lib/wallet/network-guard.tsx:16` | ✅ | R1、R2 |
| 注册页面入口 | `apps/web/app/(auth)/register/page.tsx:1` | ✅ | R1、R2 |
| `RegisterView` 组件 | `apps/web/features/registration/RegisterView.tsx:132` | ✅ | R1、R2 |
| BFF 调用封装 | `apps/web/lib/api/registration.ts:24` | ✅ | R1、R2 |
| 媒体上传 API | `apps/web/lib/api/media.ts`（未来目标路径） | 🚧 | O2 |
| 订单草稿页面 | `apps/web/app/(warehouse)/orders/[recordUid]/page.tsx`（未来目标路径） | 🚧 | O1/O2 |
| useOrderDraft Hook | `apps/web/features/orders/useOrderDraft.ts:1` | ✅ | O1 |
| 理赔工作台 | `apps/web/app/(operations)/claims/[recordUid]/page.tsx`（未来目标路径） | 🚧 | C1 |
| 质押/信用面板 | `apps/web/app/(warehouse)/staking/page.tsx:1`、`apps/web/features/staking/StakingDashboard.tsx:1`、`apps/web/features/staking/hooks/useStakingIntent.ts:1` | ✅ 初版（W1） | S1/W1 |

## 5.2 应用壳与钱包上下文
- `providers.tsx` 将 `WalletContextProvider`、`QueryClientProvider` 等全局依赖注入 App Router，保证页面渲染一致性。
- `useWalletContext`（`apps/web/lib/wallet/context.tsx:71-183`）封装钱包账户、签名与网络状态，所有需要签名/轮询的 Hook 均应依赖该上下文，而非直接读取 `@aptos-labs/wallet-adapter-react`。
- `NetworkGuard`（`apps/web/lib/wallet/network-guard.tsx:16-49`）在 R1/R2 流程中强制检查 `NEXT_PUBLIC_APTOS_NETWORK`，防止跨网络提交。

## 5.3 R1 — 注册流程 UI & 数据流
### 5.3.1 上传与缓存
```tsx
// apps/web/features/registration/RegisterView.tsx:361-417
const handleFormSubmit = async (event: FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  if (!accountAddress) {
    setUploadError('Connect your wallet before uploading documentation.');
    return;
  }
  if (alreadyRegistered) {
    setUploadError('This address is already registered.');
    return;
  }
  if (!selectedFile || !fileMeta?.hash) {
    setFileError('Upload a valid document before continuing.');
    return;
  }
  setUploadError(null);
  setIsUploading(true);
  try {
    const response = await uploadIdentityDocument({
      file: selectedFile,
      address: accountAddress,
      role,
      hash: fileMeta.hash
    });
    if (response.hash.value.toLowerCase() !== fileMeta.hash.toLowerCase()) {
      throw new Error('Hash mismatch between client and server.');
    }
    const cachePayload: PendingProfileCache = {
      role,
      hash: fileMeta.hash,
      storagePath: response.path,
      recordUid: response.recordUid,
      fileName: fileMeta.name,
      mime: fileMeta.mime,
      sizeBytes: fileMeta.sizeBytes,
      uploadedAt: new Date().toISOString(),
      profileUri: profileUri || undefined,
      notes: notes || undefined
    };
    setCachedProfile(cachePayload);
    setUploadResult({ recordUid: response.recordUid, path: response.path, hash: response.hash.value });
    setSelectedFile(null);
  } catch (error) {
    setUploadError(error instanceof Error ? error.message : 'Failed to upload documentation.');
  } finally {
    setIsUploading(false);
  }
};
```
- `uploadIdentityDocument`（`apps/web/lib/api/registration.ts:90-110`）将文件通过 `FormData` POST 到 BFF `/api/media/uploads`，并与 MediaService 的哈希校验保持对齐。
- 成功上传后缓存 `PendingProfileCache`（`RegisterView` 内部 state）以支持断点续传。

### 5.3.2 链上注册签署
```tsx
// apps/web/features/registration/RegisterView.tsx:562-641
const submitRegistration = useCallback(async () => {
  if (!accountAddress) {
    setTransactionState({ stage: 'failed', error: 'Connect your wallet before submitting.' });
    return;
  }
  if (!activeHash) {
    setTransactionState({ stage: 'failed', error: 'Upload documentation before signing the transaction.' });
    return;
  }
  setTransactionState({ stage: 'submitting' });
  try {
    const transactionInput = buildRegisterTransactionInput(activeHash);
    const transaction =
      simulationState.status === 'success'
        ? simulationState.transaction
        : await buildRegisterTransaction(activeHash);
    const result = await signAndSubmitTransaction(transactionInput);
    const txnHash =
      typeof result === 'string'
        ? result
        : result?.hash ??
          (typeof (result as any)?.transactionHash === 'string' ? (result as any).transactionHash : undefined) ??
          (typeof (result as any)?.txnHash === 'string' ? (result as any).txnHash : undefined) ??
          (typeof (result as any)?.result?.hash === 'string' ? (result as any).result.hash : undefined);
    if (!txnHash) {
      throw new Error('Wallet did not return a transaction hash.');
    }
    const explorerUrl = buildExplorerUrl(txnHash, networkStatus.expected);
    setTransactionState({ stage: 'pending', hash: txnHash, explorerUrl });
    try {
      await pollTransaction(txnHash);
      setTransactionState({ stage: 'success', hash: txnHash, explorerUrl });
      const immediateProfile: AccountProfile = {
        address: accountAddress,
        role,
        profileHash: { algo: 'blake3', value: activeHash },
        profileUri: profileUri || cachedProfile?.profileUri,
        registeredAt: new Date().toISOString(),
        orderCount: accountInfo?.orderCount
      };
      setAccountInfo(immediateProfile);
      void refreshAccountInfo();
    } catch (pollError) {
      setTransactionState({
        stage: 'failed',
        hash: txnHash,
        explorerUrl,
        error: pollError instanceof Error ? pollError.message : 'Failed to confirm transaction.'
      });
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Transaction submission failed.';
    const normalized = message.toLowerCase();
    const friendly = normalized.includes('reject') ? 'Signature request was declined in your wallet.' : message;
    setTransactionState({ stage: 'failed', error: friendly });
  }
}, [
  accountAddress,
  activeHash,
  simulationState,
  buildRegisterTransaction,
  buildRegisterTransactionInput,
  signAndSubmitTransaction,
  networkStatus.expected,
  pollTransaction,
  refreshAccountInfo,
  role,
  profileUri,
  cachedProfile,
  accountInfo
]);
```
- `buildRegisterTransactionInput` 拼接 Move 函数 `registry::register_seller`/`register_warehouse`，与链上 Anchor 对应。
- 提交成功后即时刷新本地 `AccountProfile`，随后调用 BFF `GET /api/accounts/:address`（`apps/web/lib/api/registration.ts:58-81`）拉取链下确认，满足数据流 10.2 中 FE→BFF 查询步骤。

### 5.3.3 哈希展示与提示
- `hashFileBlake3`（`apps/web/lib/crypto/blake3.ts:9-12`）在浏览器端生成 64 位小写十六进制哈希，与链上 `registry::validate_hash` 规则一致。
- UI 中 `STATUS_BADGE_CLASS` 与网络状态提示直接映射 `WalletContext.networkStatus`。

## 5.4 R2 — 档案哈希校验
- `verifyHash` 按钮触发 `AccountsService.verifyProfileHash`，前端通过 `fetchAccountProfile` 获取链下哈希，用 `hashFileBlake3` 结果与 BFF `storedHash` 对比，满足数据流 10.3。
- 错误状态通过 `setUploadError` 反馈，与 BFF 的 `ORDER_MEDIA_ERROR_CODES.HASH_MISMATCH` 保持一致（未来可接入共享常量 `@haigo/shared/config/orders`）。

## 5.5 规划场景 Anchor
| 场景 | Anchor | 说明 |
|------|------------------------|------|
| O1 订单草稿/签署 | `apps/web/features/orders/create/CreateOrderView.tsx`、`apps/web/features/orders/useOrderDraft.ts` | 调用 `POST /api/orders/drafts` 保存草稿，监听 `OrdersEventListener` 状态；需复用 `useWalletContext` 签署交易 |
| O2 仓储出库与媒体时间线 | `apps/web/features/orders/outbound/OutboundProvider.tsx`、`useOutboundForm.ts`、`OrderTimeline.tsx` | 消费 BFF `/api/orders/:recordUid`、`/timeline`，展示媒体与事件，上传成功后刷新时间线 |
| C1 理赔流程 | `apps/web/features/claims/ClaimWorkflow.tsx`、`useClaimTimeline.ts` | 接入理赔草稿 API，轮询事件进度，需展示 Fullnode 补齐的时间戳 |
| S1 质押 & 信用 | `apps/web/features/staking/StakingDashboard.tsx`、`apps/web/features/credit/CreditLeaderboard.tsx` | 聚合 BFF `/api/staking/:warehouseAddress` / `/api/credit/board`，展示余额、锁仓、信用分布 |

### 质押控制台（W1 初版）
实现锚点：
- `apps/web/lib/api/staking.ts:1`（fetchStakingIntent）
- `apps/web/features/staking/hooks/useStakingIntent.ts:1`
- `apps/web/features/staking/useStakingActions.ts:1`（stake/unstake/set_storage_fee 钱包签名）
- `apps/web/features/staking/StakingDashboard.tsx:1`

> **实现约束**：创建上述文件前需先更新本表，并在代码中引用共享 DTO（`packages/shared/src/dto/*.ts`）。

## 5.6 观测与回归
- 注册流程单测位于 `apps/web/features/registration/RegisterView.test.tsx`，涵盖钱包断连、哈希校验等场景，落地新功能时参考编写对应 RTL 测试。
- 网络/钱包故障需通过 `WalletContext` 的 `connectionError` 与 `NetworkGuard` fallback 提示，保持与数据流 10.2/10.3 的异常分支一致。
- 前端日志应携带 BFF 返回的 `x-haigo-trace-id`，后续可接入 Sentry/LogRocket 关联链路。
