# 3. é“¾ä¸Šåˆçº¦è®¾è®¡

> æœ¬ç« èŠ‚ä¾æ®ã€Š10-åœºæ™¯åŒ–ç«¯åˆ°ç«¯æ•°æ®æµã€‹å®šä¹‰çš„ R1â€“S1 åœºæ™¯ï¼Œå¯¹é“¾ä¸Šåˆçº¦çš„çŠ¶æ€ã€äº‹ä»¶ä¸è·¨æ¨¡å—äº¤äº’è¿›è¡Œé”šç‚¹åŒ–æè¿°ã€‚æ‰€æœ‰ Anchor å‡ä»¥ `è·¯å¾„:è¡Œå·` æ ‡æ³¨ï¼Œæœªè½åœ°çš„åŠŸèƒ½ä½¿ç”¨â€œæœªæ¥ç›®æ ‡è·¯å¾„â€é¢„ç•™ï¼Œè½åœ°æ—¶é¡»åŒæ­¥æ›´æ–°é”šç‚¹ä¸ä»£ç ç‰‡æ®µã€‚

## 3.1 æ¨¡å—é”šç‚¹ç´¢å¼•
| æ¨¡å— | Anchor | å®æ–½çŠ¶æ€ | è¦†ç›–åœºæ™¯ |
|------|--------|----------|----------|
| `haigo::registry` | `move/sources/registry.move:1` | âœ… å·²äº¤ä»˜ | R1 æ³¨å†Œäº‹ä»¶åŒæ­¥ã€R2 æ¡£æ¡ˆå“ˆå¸Œæ ¡éªŒ |
| `haigo::orders` | `move/sources/orders.move:1` | âœ… å·²äº¤ä»˜ï¼ˆPoCï¼‰ | O1 è®¢å•åˆ›å»ºç­¾ç½²ã€O2 ä»“å‚¨å‡ºåº“ |
| `haigo::staking` | `move/sources/staking.move:1` | âœ… å·²äº¤ä»˜ï¼ˆåˆç‰ˆ W1ï¼‰ | W1 ä»“ä¸»è´¨æŠ¼/è´¹ç‡ã€O1/O2 è´¨æŠ¼ä¿¡ç”¨å…œåº• |
| `haigo::insurance` | `move/sources/insurance.move`ï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰ | ğŸš§ è§„åˆ’ä¸­ | C1 ç†èµ”å¼€å¯/ç»“æ¡ˆ |
| `haigo::reputation` | `move/sources/reputation.move`ï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰ | ğŸš§ è§„åˆ’ä¸­ | S1 ä¿¡ç”¨è¯„åˆ†æ‰©å±• |
| `haigo::insurance_config` | `move/sources/insurance_config.move`ï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰ | ğŸš§ è§„åˆ’ä¸­ | C1/S1 è´¹ç‡ç®¡ç† |

## 3.2 R1 / R2 â€” Registry æ¨¡å—
### 3.2.1 çŠ¶æ€ç»“æ„ä¸äº‹ä»¶
```move
// move/sources/registry.move:26-72
    struct AccountRecord has store, copy, drop {
        address: address,
        role: u8,
        hash_algorithm: u8,
        hash_value: String,
        timestamp: u64,
    }

    struct Registry has key {
        accounts: Table<address, AccountRecord>,
        seller_registered_events: EventHandle<SellerRegistered>,
        warehouse_registered_events: EventHandle<WarehouseRegistered>,
        platform_registered_events: EventHandle<PlatformOperatorRegistered>,
    }

    struct SellerRegistered has store, drop {
        address: address,
        role: u8,
        hash_algorithm: u8,
        hash_value: String,
        timestamp: u64,
        sequence: u64,
    }
```
- `AccountRecord` ä¸ä¸‰ç±» `*Registered` äº‹ä»¶å…±åŒæ”¯æ’‘ BFF ç›‘å¬ï¼Œå¯¹åº”æ•°æ®æµ 10.2ã€10.3 ä¸­çš„ Indexer æ‹‰å–ã€‚
- è§’è‰²å¸¸é‡ä¸å“ˆå¸Œç®—æ³•å¸¸é‡åˆ†åˆ«ç”± [`role_seller`](move/sources/registry.move:258)ã€[`hash_algorithm_blake3`](move/sources/registry.move:270) å¯¼å‡ºï¼Œä¾›é“¾ä¸Š/é“¾ä¸‹å…±è¯†æ ¡éªŒã€‚

### 3.2.2 æ³¨å†Œå…¥å£ä¸å®ˆå«
- å–å®¶æ³¨å†Œï¼š[`registry::register_seller`](move/sources/registry.move:112) éªŒè¯å“ˆå¸Œæ ¼å¼ã€å†™å…¥è¡¨é¡¹å¹¶è§¦å‘äº‹ä»¶ï¼›ä»“åº“/å¹³å°æ³¨å†Œåˆ†åˆ«å¤ç”¨ [`register_warehouse`](move/sources/registry.move:156)ã€[`register_platform_operator`](move/sources/registry.move:199)ã€‚
- èº«ä»½å®ˆå«ï¼šè®¢å•ä¸å‡ºåº“æµç¨‹é€šè¿‡ [`registry::assert_role`](move/sources/registry.move:250) æ ¡éªŒåœ°å€è§’è‰²ï¼Œå¯¹åº”æ•°æ®æµ 10.4/10.5 ä¸­â€œé“¾ä¸Šè§’è‰²æ£€æŸ¥â€èŠ‚ç‚¹ã€‚
- è§†å›¾å‡½æ•°ï¼š[`is_registered`](move/sources/registry.move:238) ä¸ [`get_account_record`](move/sources/registry.move:245) ä¸ºé“¾ä¸‹ BFF `AccountsService` æš´éœ² `[view]` è¯»å–èƒ½åŠ›ï¼Œå¯ç›´æ¥ç”¨äºå¯¹è´¦ã€‚

### 3.2.3 æ¡£æ¡ˆå“ˆå¸Œæ ¡éªŒåŸºçº¿
- æ³¨å†Œäº‹ä»¶ä¸­å“ˆå¸Œæ ¼å¼ç»Ÿä¸€ç» [`validate_hash`](move/sources/registry.move:85) æ£€æŸ¥ï¼Œç¡®ä¿é“¾ä¸‹æ ¡éªŒä¸é“¾ä¸Šäº‹ä»¶ä¸€è‡´ã€‚
- é”™è¯¯ç  `E_INVALID_HASH_FORMAT`ï¼ˆ`move/sources/registry.move:13`ï¼‰åœ¨ BFF ä¸Šä¼ éªŒè¯å¤±è´¥æ—¶å›æ˜¾ï¼Œæ–‡æ¡£éœ€ä¿æŒä¸€è‡´ã€‚

## 3.3 O1 â€” Orders æ¨¡å—ï¼ˆè®¢å•åˆ›å»ºä¸ç­¾ç½²ï¼‰
### 3.3.1 OrderBook çŠ¶æ€å¿«ç…§
```move
// move/sources/orders.move:67-129
    struct Order has store {
        id: u64,
        seller: address,
        warehouse: address,
        status: u8,
        pricing: PricingRecord,
        logistics_inbound: Option<String>,
        logistics_outbound: Option<String>,
        created_at: u64,
        checked_in_at: Option<u64>,
        set_in_storage_at: Option<u64>,
        checked_out_at: Option<u64>,
        media_records: vector<MediaRecord>,
        insurance_blocked: bool,
    }

    struct OrderBook has key {
        orders: Table<u64, Order>,
        next_order_id: u64,
        platform_account: address,
        timeline_enabled: bool,
        timeline_events: Option<vector<TimelineEntry>>,
        order_created_events: EventHandle<OrderCreated>,
        checked_in_events: EventHandle<CheckedIn>,
        set_in_storage_events: EventHandle<SetInStorage>,
        checked_out_events: EventHandle<CheckedOut>,
    }
```
- `Order` å†…åµŒåª’ä½“ã€ä»·æ ¼ã€æ—¶é—´çº¿çŠ¶æ€ï¼Œä¸º BFF `OrdersService` ç»„è£…è®¢å•è¯¦æƒ…æä¾›æœ€å°å­—æ®µé›†ï¼ˆè§æ•°æ®æµ 10.4ï¼‰ã€‚

### 3.3.2 åˆ›å»ºæµç¨‹ä¸è·¨æ¨¡å—ä¾èµ–
```move
// move/sources/orders.move:205-265
    public entry fun create_order<CoinType>(
        seller: &signer,
        warehouse: address,
        inbound_logistics: Option<String>,
        amount: u64,
        insurance_fee: u64,
        platform_fee: u64,
        initial_media_category: Option<String>,
        initial_media_hash: Option<vector<u8>>,
    ) acquires OrderBook {
        assert!(exists<OrderBook>(@haigo), error::not_found(E_NOT_INITIALIZED));
        let book = borrow_global_mut<OrderBook>(@haigo);

        let seller_addr = signer::address_of(seller);
        registry::assert_role(seller_addr, registry::role_seller());
        registry::assert_role(warehouse, registry::role_warehouse());

        let total = amount + insurance_fee + platform_fee;
        staking::assert_min_credit(seller_addr, total);
        coin::transfer<CoinType>(seller, book.platform_account, total);

        let now = timestamp::now_seconds();

        let media_records = vector::empty<MediaRecord>();
        if (option::is_some(&initial_media_category)) {
            assert!(option::is_some(&initial_media_hash), error::invalid_argument(E_MEDIA_STAGE_MISMATCH));
            let category_ref = option::borrow(&initial_media_category);
            let hash_ref = option::borrow(&initial_media_hash);
            let record = new_media_record(
                MEDIA_STAGE_CREATED,
                clone_string(category_ref),
                clone_bytes(hash_ref),
                now,
            );
            vector::push_back(&mut media_records, record);
        } else {
            assert!(option::is_none(&initial_media_hash), error::invalid_argument(E_MEDIA_STAGE_MISMATCH));
        };

        let pricing = PricingRecord {
            amount,
            insurance_fee,
            platform_fee,
            total,
            currency: type_info::type_of<CoinType>(),
        };

        let order_id = book.next_order_id;
        book.next_order_id = order_id + 1;

        let order = Order {
            id: order_id,
            seller: seller_addr,
            warehouse,
            status: ORDER_STATUS_CREATED,
            pricing,
            logistics_inbound: clone_option_string(&inbound_logistics),
            logistics_outbound: option::none(),
            created_at: now,
            checked_in_at: option::none(),
            set_in_storage_at: option::none(),
            checked_out_at: option::none(),
            media_records,
            insurance_blocked: false,
        };

        table::add(&mut book.orders, order_id, order);

        emit_order_created(book, order_id);
        record_timeline(book, order_id, ORDER_STATUS_CREATED, option::none(), now);
    }
```
- `registry::assert_role`ã€`staking::assert_min_credit` åˆ†åˆ«ä¿éšœä¸»ä½“èº«ä»½ä¸ä¿¡ç”¨é¢åº¦ï¼Œå¯¹åº” BFF æ•°æ®æµä¸­â€œé“¾ä¸Šå®ˆå«â€èŠ‚ç‚¹ã€‚
- è®¢å•äº‹ä»¶ `OrderCreated`ï¼ˆ`move/sources/orders.move:97`ï¼‰è¢« BFF è®¡åˆ’ä¸­çš„ `OrdersEventListener` æ¶ˆè´¹ï¼Œéœ€åœ¨é“¾ä¸‹ä¿å­˜ `pricing` ä¸åˆå§‹åª’ä½“ã€‚

## 3.4 O2 â€” ä»“å‚¨å‡ºå…¥åº“ä¸åª’ä½“å­˜è¯
- å…¥åº“ç­¾æ”¶ï¼š[`orders::check_in`](move/sources/orders.move:268) æ ¡éªŒä»“åº“è§’è‰²å¹¶è¿½åŠ åª’ä½“è®°å½•ï¼Œè§¦å‘ `CheckedIn` äº‹ä»¶ä¾› BFF æ—¶é—´çº¿å›æ”¾ã€‚
- å…¥åº“åˆ°ä»“å‚¨ï¼š[`orders::set_in_storage`](move/sources/orders.move:298) ä»…å…è®¸çŠ¶æ€ä» `ORDER_STATUS_WAREHOUSE_IN` è¿ç§»ï¼Œä¿æŒäº‹ä»¶é¡ºåºä¸€è‡´ã€‚
- å‡ºåº“ç»“ç®—ï¼š[`orders::check_out`](move/sources/orders.move:324) é™åˆ¶æ“ä½œè€…ä¸ºä»“åº“æˆ–å¹³å°è´¦æˆ·ï¼Œä¸”éœ€é€šè¿‡ `insurance_blocked` æ ‡å¿—ï¼›è¯¥æ ‡å¿—åç»­ç”± `insurance` æ¨¡å—ä¸é“¾ä¸‹ç†èµ”æµç¨‹åŒæ­¥æ›´æ–°ã€‚
- åª’ä½“å“ˆå¸Œæ ¡éªŒï¼šå†…éƒ¨ `assert_hash_valid`ï¼ˆ`move/sources/orders.move:457`ï¼‰å¼ºåˆ¶ 32 å­—èŠ‚ BLAKE3 åŸå§‹å€¼ï¼Œä¸é“¾ä¸‹åª’ä½“ä¸Šä¼ è¿”å›å€¼äº’è®¤ã€‚

## 3.5 S1/W1 â€” è´¨æŠ¼ä¸å­˜å‚¨è´¹
```move
// move/sources/staking.move:12-24
    public fun assert_min_credit(addr: address, required: u64) acquires CreditBook {
        if (!exists<CreditBook>(@haigo)) {
            return;
        };

        let book = borrow_global<CreditBook>(@haigo);
        if (!table::contains(&book.credits, addr)) {
            assert!(required == 0, error::invalid_state(E_INSUFFICIENT_CREDIT));
            return;
        };
        let credit = *table::borrow(&book.credits, addr);
        assert!(credit >= required, error::invalid_state(E_INSUFFICIENT_CREDIT));
    }
```
- `staking::assert_min_credit` è¢«è®¢å•åˆ›å»ºã€å‡ºåº“ä»¥åŠæœªæ¥è´¨æŠ¼/ä¿¡ç”¨æµç¨‹å¤ç”¨ï¼Œå¯¹åº”æ•°æ®æµ 10.7 ä¸­çš„ä¿¡ç”¨æŸ¥è¯¢èŠ‚ç‚¹ã€‚
- è´¨æŠ¼èµ„äº§ä¸ä¿¡ç”¨è®°è´¦æœªæ¥å°†æ‰©å±• `CreditBook` ä¸ºç»“æ„ä½“è¡¨ï¼Œä¿æŒ Anchor åœ¨ `move/sources/staking.move`ã€‚

### 3.5.1 Staking æ‰©å±•æ¥å£ï¼ˆå·²å®ç° åˆç‰ˆï¼‰
- è´¨æŠ¼/è§£æŠ¼ï¼ˆä»“åº“ï¼‰ï¼š
  - `stake<CoinType>(warehouse: &signer, amount: u64)` â€” move/sources/staking.move:1
  - `unstake<CoinType>(warehouse: &signer, amount: u64)` â€” move/sources/staking.move:1
- å­˜å‚¨è´¹è®¾ç½®ï¼š
  - `set_storage_fee(warehouse: &signer, fee_per_unit: u64)` â€” move/sources/staking.move:1

çº¦æŸï¼š
- ä»… `warehouse` è§’è‰²å¯è°ƒç”¨ï¼ˆ`registry::assert_role`ï¼‰ã€‚
- `fee_per_unit â‰¤ 10000`ï¼ˆbps ä¸Šé™ï¼‰ï¼Œ`amount > 0`ã€‚
- PoC é˜¶æ®µä»…é“¾ä¸Šè®°è´¦ï¼Œä¸åšèµ„é‡‘é”å®šï¼›äº‹ä»¶å¯¹å¤–å¯è§ï¼ˆè§ä¸‹ï¼‰ã€‚

### 3.5.2 äº‹ä»¶ç»“æ„ï¼ˆå·²å®ç°ï¼‰
```move
struct StakeChanged has store, drop {
  warehouse: address,
  delta: u64,
  new_amount: u64,
  timestamp: u64,
}

struct StorageFeeUpdated has store, drop {
  warehouse: address,
  fee_per_unit: u64,
  timestamp: u64,
}
```
äº‹ä»¶é€šè¿‡ `EventHandle<StakeChanged>` ä¸ `EventHandle<StorageFeeUpdated>` æš´éœ²ï¼Œä¾› Indexer/BFF æ¶ˆè´¹ã€‚

### 3.5.3 è§†å›¾å‡½æ•°ï¼ˆå·²å®ç°ï¼‰
- `public fun get_stake(addr: address): u64` â€” è¿”å›åœ°å€çš„å½“å‰è´¨æŠ¼ä»“ä½ï¼ˆmove/sources/staking.move:1ï¼‰ã€‚
- `public fun get_storage_fee(addr: address): u64` â€” è¿”å›åœ°å€å½“å‰å­˜å‚¨è´¹ï¼ˆfee_per_unitï¼‰ã€‚

è¯´æ˜ï¼šé“¾ä¸Šè§†å›¾ä¸ºæƒå¨æ¥æºï¼›BFF è¯»å–è§†å›¾å¤±è´¥æ—¶å›è½æœ¬åœ°ç¼“å­˜ï¼ˆè§ã€Š4-é“¾ä¸‹æœåŠ¡ä¸æ•°æ®æµã€‹ï¼‰ã€‚

## 3.6 è§„åˆ’ä¸­æ¨¡å—ä¸ Anchor çº¦å®š
- ç†èµ”æµç¨‹ï¼š`haigo::insurance` æ¨¡å—å°†åœ¨ `move/sources/insurance.moveï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰` å®šä¹‰ `Claim` èµ„æºä¸ `ClaimOpened`/`ClaimResolved` äº‹ä»¶ï¼Œæ”¯æ’‘æ•°æ®æµ 10.6ï¼›æ¥å£éœ€é¢„ç•™ `assert_no_pending_claim(order_id)` ä¾›å‡ºåº“å‰æ£€æŸ¥ã€‚
- è´¹ç‡é…ç½®ï¼š`haigo::insurance_config` è´Ÿè´£ä¿é™©è´¹ç‡/ç‰ˆæœ¬ç®¡ç†ï¼ŒAnchor é¢„ç•™åœ¨ `move/sources/insurance_config.moveï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰`ï¼Œä¾›é“¾ä¸‹è´¹ç‡æŸ¥è¯¢ã€‚
- ä¿¡ç”¨è¯„åˆ†ï¼š`haigo::reputation` å°†åœ¨ `move/sources/reputation.moveï¼ˆæœªæ¥ç›®æ ‡è·¯å¾„ï¼‰` å®šä¹‰è¯„åˆ†å¿«ç…§ä¸äº‹ä»¶ï¼Œç”¨äºæ•°æ®æµ 10.7ã€‚

## 3.7 è·¨æ¨¡å—äº¤äº’æ‘˜è¦
- è®¢å•ç”Ÿå‘½å‘¨æœŸä¾èµ–æ³¨å†Œä¸è´¨æŠ¼å®ˆå«ï¼ˆ`registry::assert_role`ã€`staking::assert_min_credit`ï¼‰ï¼Œæœªæ¥éœ€è¿½åŠ  `insurance::assert_no_pending_claim`ï¼›é“¾ä¸Šæµç¨‹åœ¨ `orders::check_out` ä¸­ä¸²è”ï¼ˆ`move/sources/orders.move:333-358`ï¼‰ã€‚
- BFF ç›‘å¬å±‚éœ€å…³æ³¨å››ç±»è®¢å•äº‹ä»¶ï¼ˆ`move/sources/orders.move:462-517`ï¼‰ï¼Œå¹¶ç»“åˆ Fullnode äº‹åŠ¡ä¿¡æ¯ç”Ÿæˆç»Ÿä¸€æ—¶é—´çº¿ï¼›å¯¹åº”å®ç°è¯¦è§ã€Š4-é“¾ä¸‹æœåŠ¡ä¸æ•°æ®æµã€‹ã€‚
- å•å…ƒæµ‹è¯•è¦†ç›–åœ¨ `registry` ä¸ `orders` æ–‡ä»¶å°¾éƒ¨ï¼ˆä¾‹å¦‚ [`test_register_seller_success`](move/sources/registry.move:281)ï¼‰ï¼Œå¯ä½œä¸ºé“¾ä¸‹æ¨¡æ‹Ÿä¸éªŒæ”¶åŸºçº¿ã€‚
