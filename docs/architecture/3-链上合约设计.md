# 3. 链上合约设计
| 模块 | 功能要点 | 主要事件 |
|------|----------|----------|
| `hai_go::registry` | 商家/仓主注册、档案哈希存储；重复注册和权限校验 | `SellerRegistered`, `WarehouseRegistered` |
| `hai_go::orders` | 订单状态机（`ORDER_CREATED → WAREHOUSE_IN → IN_STORAGE → WAREHOUSE_OUT`）、费用记录、物流单号、媒体哈希 | `OrderCreated`, `CheckedIn`, `SetInStorage`, `CheckedOut` |
| `hai_go::staking` | APT/稳定币质押与信用权重；多次变更生成快照 | `StakeChanged` |
| `hai_go::insurance` | 理赔开启、审批/拒绝及赔付金额记录 | `ClaimOpened`, `ClaimResolved` |
| `hai_go::reputation` | 仓主评分与链下评价哈希记录 | `RatingSubmitted` |

## 3.1 Registry 模块
### 状态结构
- 平台资源账户发布 `Registry` 资源，托管在 `hai_go::registry` 模块下。
- `Registry` 内部维护 `table::Table<address, AccountRecord>`，键为注册地址，值包含：
  - `role: Role`：`seller` / `warehouse` / `platform` 三态；支持未来扩展新角色。
  - `metadata_hash: HashValue`：`struct HashValue { algorithm: u8, value: vector<u8>, uri: option::Option<String> }`。
  - `registered_at: u64`：注册时的链上版本号，供索引器回放。
  - `event_seq: u64`：注册事件在模块内的序号。
- 额外布尔映射 `registered_roles: table::Table<(address, Role), bool>`，防止同地址重复注册同一角色。
- `RegistryEvents` 结构保存 `SellerRegistered`、`WarehouseRegistered` 事件句柄，供 Aptos Indexer 与链下服务消费。

### 关键入口函数
- `public entry fun register_seller(account: &signer, metadata: HashValue)`
  - 仅允许 `signer` 自己注册；若地址已注册卖家角色则中断。
  - 写入 `AccountRecord` 并触发 `SellerRegistered { account, metadata }`。
- `public entry fun register_warehouse(account: &signer, metadata: HashValue)`：与卖家注册逻辑一致。
- `public fun assert_role(addr: address, role: Role)`：供其他模块（订单、质押等）在入口函数中验证身份。
- `public entry fun update_metadata(account: &signer, metadata: HashValue)`：允许角色更新档案哈希，触发 `MetadataUpdated`（计划中的事件，当前版本留作扩展）。

### 约束与交互
- Registry 是所有业务模块的前置条件：`orders::create_order`、`staking::deposit`、`insurance::open_claim` 等函数都会调用 `registry::assert_role`。
- 平台资源账户负责初次发布和升级模块，并在部署脚本中输出模块地址（写入 `apps/bff` 配置与前端 `.env.local`）。
- 注册事件的 payload 与 `docs/epic/epic-1-infrastructure-on-chain-registration-基础设施与链上注册.md` 的 Story 1.2 接受标准对齐，链下索引服务使用事件版本 + 序号进行去重。

## 3.2 Orders 模块
### 状态结构
- `OrderBook` 资源挂载在平台资源账户下：
  - `orders: table::Table<u64, Order>`：以自增 ID 存储订单。
  - `next_order_id: u64`：每次 `create_order` 时递增；ID 同时作为链下系统的主键。
  - `timeline_events: table::Table<u64, vector<OrderEvent>>`：用于快速回放订单状态变更（可选启用）。
- `struct Order` 字段：
  - `seller: address`、`warehouse: address`
  - `status: OrderStatus`（枚举：`ORDER_CREATED`、`WAREHOUSE_IN`、`IN_STORAGE`、`WAREHOUSE_OUT`）
  - `logistics_id: option::Option<String>`：物流单号
  - `media_hashes: vector<HashValue>`：媒体/凭证哈希
  - `pricing: PricingRecord`：费用明细，含结算货币与金额
  - `checked_in_at / out_at: option::Option<u64>`：关键时间戳

### 状态机流程
1. `create_order(seller_signer, warehouse_addr, payload)`：
   - 校验卖家已注册，仓主角色存在。
   - 初始化状态为 `ORDER_CREATED`，写入价格、媒体等可选字段。
   - 触发 `OrderCreated { order_id, seller, warehouse, pricing }`。
2. `check_in(warehouse_signer, order_id, payload)`：
   - 仅仓主签名可执行；状态必须为 `ORDER_CREATED`。
   - 记录入库时间、初次质检哈希，状态变为 `WAREHOUSE_IN`。
3. `set_in_storage(warehouse_signer, order_id, storage_info)`：
   - 状态要求 `WAREHOUSE_IN`；允许写入仓储位置信息、追加媒体哈希。
   - 触发 `SetInStorage`。
4. `check_out(platform_signer, order_id, payload)`：
   - 平台或指定清关人执行；状态要求 `IN_STORAGE`。
   - 更新物流单号、出库时间，状态变为 `WAREHOUSE_OUT`。

### 约束与交互
- 订单所有入口函数在执行前调用 `registry::assert_role`，确保身份有效。
- 可选集成 `staking::assert_min_credit(seller)`，在创建订单时校验卖家信用权重。
- 后续扩展：在 `check_out` 中对接 `insurance::resolve_claim`，确保存在未结的理赔时不可出库。

### 事件载荷
| 事件 | 字段 |
|------|------|
| `OrderCreated` | `order_id`, `seller`, `warehouse`, `pricing.currency`, `pricing.amount`
| `CheckedIn` | `order_id`, `warehouse`, `inspector`, `media_hash`
| `SetInStorage` | `order_id`, `warehouse`, `storage_code`, `media_hash`
| `CheckedOut` | `order_id`, `operator`, `logistics_id`, `released_at`

## 3.3 Staking 模块
### 状态结构
- `StakingPool` 资源挂在平台账户下：
  - `positions: table::Table<address, StakePosition>`：同一地址可存在多笔质押凭证。
  - `snapshots: table::Table<u64, CreditSnapshot>`：针对每次质押变动生成快照，供信用评分引用。
  - `total_locked_apt`、`total_locked_stable`：方便前端展示与风控监控。
- `struct StakePosition` 字段：`owner`, `apt_amount`, `stable_amount`, `weight`, `locked_until`。
- `struct CreditSnapshot`：`seq_id`, `owner`, `weight`, `version`。

### 关键入口函数
- `public entry fun deposit_apt(staker: &signer, amount: u64)`：
  - 调用者需完成 `coin::transfer<AptosCoin>` 到池子账户。
  - 更新权重 `weight = f(apt_amount, stable_amount, tenure)`，触发 `StakeChanged`。
- `public entry fun deposit_stable(staker: &signer, amount: u64)`：支持稳定币质押，稳定币 `CoinType` 在发布时配置。
- `public entry fun withdraw(staker: &signer, amount: u64)`：
  - 校验尚未锁定或锁定期已过；若余额不足则中断。
  - 更新快照并释放资产给调用者。
- `public fun get_weight(addr: address): u128`：供订单、保险模块读取信用权重；若无质押记录返回 0。

### 约束与交互
- `orders::create_order` 可配置最低权重阈值，通过 `staking::get_weight` 校验。
- `insurance::open_claim` 在评估赔付时会参考卖家/仓主的最新权重，影响是否需要额外抵押。
- 平台可在治理上配置质押权重算法，算法实现封装在 `internal::calc_weight`。

## 3.4 Insurance 模块
### 状态结构
- `InsuranceVault` 资源挂在平台账户：
  - `claims: table::Table<u64, Claim>`：索引与订单 ID 对齐。
  - `resolvers: table::Table<address, bool>`：记录具有审批权限的账户。
  - `reserve_balance: u64`：理赔资金池余额（APT 或稳定币）。
- `struct Claim` 字段：`claim_id`, `order_id`, `initiator`, `status`, `requested_amount`, `approved_amount`, `created_at`, `resolved_at`, `attachments`。
- 状态枚举：`PENDING`、`APPROVED`、`REJECTED`、`PAID`。

### 关键入口函数
- `open_claim(signer: &signer, order_id: u64, payload)`：
  - 允许卖家、仓主或运营人员根据订单状态提交理赔申请。
  - 校验订单当前状态，禁止重复存在未结理赔。
  - 触发 `ClaimOpened { claim_id, order_id, initiator, requested_amount }`。
- `review_claim(resolver: &signer, claim_id: u64, decision)`：
  - 仅 `resolvers` 白名单中的账户可执行，decision 包含通过/拒绝、赔付金额。
  - 更新状态并触发 `ClaimResolved`。
- `payout(platform: &signer, claim_id: u64)`：
  - 平台账户执行，将赔付金额从 `reserve_balance` 转移给索赔方。
  - 同步更新订单模块中的状态（如需锁定订单出库）。

### 约束与交互
- 与订单模块联动：理赔开启后 `orders::check_out` 需要确认没有 `PENDING/APPROVED` 的理赔。
- 与质押模块联动：若卖家信用权重低于阈值，理赔结果可要求额外质押或自动扣减 `StakePosition`。
- 事件供 BFF 推送通知与风控系统使用。

## 3.5 Reputation 模块
### 状态结构
- `ReputationCenter` 资源：
  - `warehouse_scores: table::Table<address, RatingAggregate>`
  - `seller_scores: table::Table<address, RatingAggregate>`（预留）
  - `reviews: table::Table<u64, ReviewRecord>`：记录链下评价哈希。
- `struct RatingAggregate`：`count`, `sum`, `last_updated`, `weight`
- `struct ReviewRecord`：`order_id`, `author`, `rating`, `comment_hash`, `evidence_uri`

### 关键入口函数
- `submit_rating(signer: &signer, order_id: u64, score: u8, comment_hash: HashValue)`：
  - 仅订单参与双方可评价；评分范围 1–5。
  - 合并 `RatingAggregate`，触发 `RatingSubmitted { order_id, warehouse, score }`。
- `get_average_score(addr: address)`：供前端与 BFF 展示。
- `attach_review_evidence(platform: &signer, review_id: u64, uri: String)`：运营补充证据链接。

### 约束与交互
- 依赖订单模块确保订单已完成（`WAREHOUSE_OUT`），否则无法评分。
- 评分结果可回写到质押权重公式，形成信用闭环。

## 3.6 模块交互与依赖关系
- Registry 提供身份验证基础，所有入口函数首先调用。
- Orders 与 Insurance 共用订单 ID，并通过事件让链下服务建立时间线。
- Staking 输出的信用权重为 Orders/Insurance/Reputation 的风控输入。
- Reputation 计算结果反馈给 Staking，平台可周期性执行 `adjust_weight_from_reputation()` 更新质押权重。
- 所有模块的事件都通过索引器写入 Postgres，BFF 提供统一查询接口。

## 3.7 权限与安全控制
- 平台资源账户持有模块发布权，同时维护 `CapabilityStore`：
  - `orders` 模块需要授予仓主、运营多签账户，以支持代办操作。
  - `insurance` 的 `resolvers` 列表由治理提案更新，避免单点审批。
- 所有入口函数均使用 `aptos_std::error` 模块返回明确错误码，方便前端与 BFF 区分异常：
  - `E_NOT_REGISTERED`、`E_ROLE_MISMATCH`、`E_INVALID_STATUS_TRANSITION`、`E_INSUFFICIENT_STAKE` 等。
- 避免重入：Move 的资源语义保证单笔事务内不会出现重入问题，但我们在入口函数中避免调用外部模块的 entry function，仅调用 `public fun` 读取状态。

## 3.8 事件与索引策略
| 事件 | 索引消费 | 说明 |
|------|----------|------|
| `SellerRegistered` / `WarehouseRegistered` | Hasura 监听 + BFF 缓存 | 填充账户基础信息表，Story 1.4 的索引服务使用该事件。
| `Order*` 系列 | Hasura + Webhook 通知 | 用于订单时间线、推送仓主端提醒。
| `StakeChanged` | 风控服务 | 重新计算信用权重和评估保证金余额。
| `ClaimOpened` / `ClaimResolved` | 运营面板 + 报表 | 跟踪理赔进度、输出赔付统计。
| `RatingSubmitted` | Reputation 聚合 | 生成仓主/商家评分，触发质押权重调整任务。

事件 payload 统一遵循：地址字段使用 `address`，金额使用 `u64`（最小单位），字符串使用 `String` 或 `vector<u8>`，确保索引器类型兼容。

## 3.9 测试与部署
- Move 单元测试覆盖：正常注册/订单流程、权限校验、状态机非法跳转、重复调用、事件字段校验。Orders 使用表驱动测试验证状态机。
- 集成测试：通过 Forge/E2E 事务脚本模拟跨模块调用，例如“卖家质押→下单→仓主入库→关闭订单→提交评分”。
- 部署：使用 `scripts/deploy.ts` 统一发布所有模块，脚本在完成后输出模块地址与初始资源账户；同时将地址写入 `apps/bff/.env` 与前端 `apps/web/.env.local`。部署日志归档到 `docs/releases/`。
- 升级：采用资源账户 + `code::publish_package_txn`；升级前执行 `compatibility_check`，确保现有资源布局兼容。必要时通过迁移脚本迭代 `table` 数据。

### 3.2.4 媒体存证字段与约束
- `struct HashValue` 扩展：除 `algorithm`、`value`、`uri`，还包含可选 `category`（`inbound_photo`、`inspection_video`、`outbound_manifest` 等），便于链下服务区分用途。
- `Order` 中 `media_hashes` 设计为 `vector<MediaRecord>`：
  ```move
  struct MediaRecord has copy, drop, store {
      hash: HashValue,
      stage: MediaStage, // enum: inbound, storage, outbound
      note: option::Option<String>,
  }
  ```
  - `create_order` 可附带初始媒体（如下单凭证）。
  - `check_in`、`set_in_storage`、`check_out` 分别追加对应 stage 的媒体；若 `stage` 与当前函数不匹配则 abort(`E_MEDIA_STAGE_MISMATCH`).
- 事件字段补充 `media_hashes: vector<HashValue>`，链下索引按顺序解析，确保与 BFF `order_media_assets` 匹配。
- 所有哈希统一为 256-bit BLAKE3，小写十六进制；链上通过 `vector_length == 32` 断言长度，异常时返回 `E_INVALID_MEDIA_HASH`。

### 3.2.5 费用与支付约束
- `PricingRecord` 包含：
  ```move
  struct PricingRecord has copy, drop, store {
      currency: TypeInfo, // Coin 类型，默认为 AptosCoin
      amount: u64,        // 主费用，单位 Octa
      insurance_fee: u64, // 可选保险费用
      platform_fee: u64,  // 未来治理用途
  }
  ```
- `create_order` 要求调用者同时转入 `amount + insurance_fee + platform_fee` 到平台资金账户；采用 `coin::transfer` 保证原子性。
- `set_in_storage` 可记录额外仓储费用（`storage_fee`），但只更新订单结构，实际扣费通过链下结算或未来扩展。
- 所有费用更新会触发 `OrderPricingUpdated` 事件（预留），供风控/财务索引。

### 3.2.6 Story 对齐清单
| Story | 链上实现重点 | 相关小节 |
|-------|--------------|----------|
| 2.1 Order Lifecycle Move Module | 状态机函数、事件结构、费用与媒体字段、错误码规范；单元测试覆盖正常与异常路径。 | §3.2、§3.2.4、§3.2.5 |
| 2.2 Order Creation & Fee Payment Flow | `create_order` 入参校验、转账逻辑、费用记录、初始媒体校验；为前端提供 `order_id` 与 `record_uid` 映射（`record_uid = order_id` 或链下生成）。 | §3.2、§3.2.5 |
| 2.3 Inbound Media Upload & Hash Verification | `check_in` 追加媒体、校验哈希格式、记录入库时间；与 `registry::assert_role(warehouse)` 联动。 | §3.2.4 |
| 2.4 Fulfillment & Order Closure | `check_out` 权限控制（仓主/平台）、出库媒体、物流单号更新、事件字段；阻止存在未结理赔的订单出库。 | §3.2、§3.4 |

### 3.2.7 测试矩阵（Epic 2）
- **正向流程**：`create_order → check_in → set_in_storage → check_out`，断言状态与费率/媒体数据一致。
- **身份错误**：卖家尝试 `check_in`、仓主调用 `create_order`，触发 `E_ROLE_MISMATCH`。
- **状态机跳跃**：直接 `check_out` 未入库的订单，预期 `E_INVALID_STATUS_TRANSITION`。
- **重复媒体/哈希异常**：传入非 32 字节哈希或 stage 不匹配，预期 `E_INVALID_MEDIA_HASH`、`E_MEDIA_STAGE_MISMATCH`。
- **费用不足**：转账金额小于 `amount + insurance_fee`，预期 `E_INSUFFICIENT_FUNDS`。

### 3.2.8 与链下协作要点
- 事件 payload 中包含 `chain_timestamp`（通过 `timestamp::now_seconds()` 转换），供索引器对齐时间线。
- `order_id` 为递增 `u64`，链下使用同值生成 `record_uid`（可格式化为 `HG-{yyyy}-{seq}`）。
- 提供 `public fun get_pricing(order_id)`、`get_media(order_id)` 只读函数，方便索引器直接读取资源，减少重复解析。
- 未来若引入治理，可将 `platform_fee` 累计于 `staking` 模块的奖励池；当前版本保留字段以兼容后续升级。

