# 3. 链上合约设计

> 本章节依据《10-场景化端到端数据流》定义的 R1–S1 场景，对链上合约的状态、事件与跨模块交互进行锚点化描述。所有 Anchor 均以 `路径:行号` 标注，未落地的功能使用“未来目标路径”预留，落地时须同步更新锚点与代码片段。

## 3.1 模块锚点索引
| 模块 | Anchor | 实施状态 | 覆盖场景 |
|------|--------|----------|----------|
| `haigo::registry` | `move/sources/registry.move:1` | ✅ 已交付 | R1 注册事件同步、R2 档案哈希校验 |
| `haigo::orders` | `move/sources/orders.move:1` | ✅ 已交付（PoC） | O1 订单创建签署、O2 仓储出库 |
| `haigo::staking` | `move/sources/staking.move:1` | ✅ 已交付（初版 W1） | W1 仓主质押/费率、O1/O2 质押信用兜底 |
| `haigo::insurance` | `move/sources/insurance.move`（未来目标路径） | 🚧 规划中 | C1 理赔开启/结案 |
| `haigo::reputation` | `move/sources/reputation.move`（未来目标路径） | 🚧 规划中 | S1 信用评分扩展 |
| `haigo::insurance_config` | `move/sources/insurance_config.move`（未来目标路径） | 🚧 规划中 | C1/S1 费率管理 |

## 3.2 R1 / R2 — Registry 模块
### 3.2.1 状态结构与事件
```move
// move/sources/registry.move:26-72
    struct AccountRecord has store, copy, drop {
        address: address,
        role: u8,
        hash_algorithm: u8,
        hash_value: String,
        timestamp: u64,
    }

    struct Registry has key {
        accounts: Table<address, AccountRecord>,
        seller_registered_events: EventHandle<SellerRegistered>,
        warehouse_registered_events: EventHandle<WarehouseRegistered>,
        platform_registered_events: EventHandle<PlatformOperatorRegistered>,
    }

    struct SellerRegistered has store, drop {
        address: address,
        role: u8,
        hash_algorithm: u8,
        hash_value: String,
        timestamp: u64,
        sequence: u64,
    }
```
- `AccountRecord` 与三类 `*Registered` 事件共同支撑 BFF 监听，对应数据流 10.2、10.3 中的 Indexer 拉取。
- 角色常量与哈希算法常量分别由 [`role_seller`](move/sources/registry.move:258)、[`hash_algorithm_blake3`](move/sources/registry.move:270) 导出，供链上/链下共识校验。

### 3.2.2 注册入口与守卫
- 卖家注册：[`registry::register_seller`](move/sources/registry.move:112) 验证哈希格式、写入表项并触发事件；仓库/平台注册分别复用 [`register_warehouse`](move/sources/registry.move:156)、[`register_platform_operator`](move/sources/registry.move:199)。
- 身份守卫：订单与出库流程通过 [`registry::assert_role`](move/sources/registry.move:250) 校验地址角色，对应数据流 10.4/10.5 中“链上角色检查”节点。
- 视图函数：[`is_registered`](move/sources/registry.move:238) 与 [`get_account_record`](move/sources/registry.move:245) 为链下 BFF `AccountsService` 暴露 `[view]` 读取能力，可直接用于对账。

### 3.2.3 档案哈希校验基线
- 注册事件中哈希格式统一经 [`validate_hash`](move/sources/registry.move:85) 检查，确保链下校验与链上事件一致。
- 错误码 `E_INVALID_HASH_FORMAT`（`move/sources/registry.move:13`）在 BFF 上传验证失败时回显，文档需保持一致。

## 3.3 O1 — Orders 模块（订单创建与签署）
### 3.3.1 OrderBook 状态快照
```move
// move/sources/orders.move:67-129
    struct Order has store {
        id: u64,
        seller: address,
        warehouse: address,
        status: u8,
        pricing: PricingRecord,
        logistics_inbound: Option<String>,
        logistics_outbound: Option<String>,
        created_at: u64,
        checked_in_at: Option<u64>,
        set_in_storage_at: Option<u64>,
        checked_out_at: Option<u64>,
        media_records: vector<MediaRecord>,
        insurance_blocked: bool,
    }

    struct OrderBook has key {
        orders: Table<u64, Order>,
        next_order_id: u64,
        platform_account: address,
        timeline_enabled: bool,
        timeline_events: Option<vector<TimelineEntry>>,
        order_created_events: EventHandle<OrderCreated>,
        checked_in_events: EventHandle<CheckedIn>,
        set_in_storage_events: EventHandle<SetInStorage>,
        checked_out_events: EventHandle<CheckedOut>,
    }
```
- `Order` 内嵌媒体、价格、时间线状态，为 BFF `OrdersService` 组装订单详情提供最小字段集（见数据流 10.4）。

### 3.3.2 创建流程与跨模块依赖
```move
// move/sources/orders.move:205-265
    public entry fun create_order<CoinType>(
        seller: &signer,
        warehouse: address,
        inbound_logistics: Option<String>,
        amount: u64,
        insurance_fee: u64,
        platform_fee: u64,
        initial_media_category: Option<String>,
        initial_media_hash: Option<vector<u8>>,
    ) acquires OrderBook {
        assert!(exists<OrderBook>(@haigo), error::not_found(E_NOT_INITIALIZED));
        let book = borrow_global_mut<OrderBook>(@haigo);

        let seller_addr = signer::address_of(seller);
        registry::assert_role(seller_addr, registry::role_seller());
        registry::assert_role(warehouse, registry::role_warehouse());

        let total = amount + insurance_fee + platform_fee;
        staking::assert_min_credit(seller_addr, total);
        coin::transfer<CoinType>(seller, book.platform_account, total);

        let now = timestamp::now_seconds();

        let media_records = vector::empty<MediaRecord>();
        if (option::is_some(&initial_media_category)) {
            assert!(option::is_some(&initial_media_hash), error::invalid_argument(E_MEDIA_STAGE_MISMATCH));
            let category_ref = option::borrow(&initial_media_category);
            let hash_ref = option::borrow(&initial_media_hash);
            let record = new_media_record(
                MEDIA_STAGE_CREATED,
                clone_string(category_ref),
                clone_bytes(hash_ref),
                now,
            );
            vector::push_back(&mut media_records, record);
        } else {
            assert!(option::is_none(&initial_media_hash), error::invalid_argument(E_MEDIA_STAGE_MISMATCH));
        };

        let pricing = PricingRecord {
            amount,
            insurance_fee,
            platform_fee,
            total,
            currency: type_info::type_of<CoinType>(),
        };

        let order_id = book.next_order_id;
        book.next_order_id = order_id + 1;

        let order = Order {
            id: order_id,
            seller: seller_addr,
            warehouse,
            status: ORDER_STATUS_CREATED,
            pricing,
            logistics_inbound: clone_option_string(&inbound_logistics),
            logistics_outbound: option::none(),
            created_at: now,
            checked_in_at: option::none(),
            set_in_storage_at: option::none(),
            checked_out_at: option::none(),
            media_records,
            insurance_blocked: false,
        };

        table::add(&mut book.orders, order_id, order);

        emit_order_created(book, order_id);
        record_timeline(book, order_id, ORDER_STATUS_CREATED, option::none(), now);
    }
```
- `registry::assert_role`、`staking::assert_min_credit` 分别保障主体身份与信用额度，对应 BFF 数据流中“链上守卫”节点。
- 订单事件 `OrderCreated`（`move/sources/orders.move:97`）被 BFF 计划中的 `OrdersEventListener` 消费，需在链下保存 `pricing` 与初始媒体。

## 3.4 O2 — 仓储出入库与媒体存证
- 入库签收：[`orders::check_in`](move/sources/orders.move:268) 校验仓库角色并追加媒体记录，触发 `CheckedIn` 事件供 BFF 时间线回放。
- 入库到仓储：[`orders::set_in_storage`](move/sources/orders.move:298) 仅允许状态从 `ORDER_STATUS_WAREHOUSE_IN` 迁移，保持事件顺序一致。
- 出库结算：[`orders::check_out`](move/sources/orders.move:324) 限制操作者为仓库或平台账户，且需通过 `insurance_blocked` 标志；该标志后续由 `insurance` 模块与链下理赔流程同步更新。
- 媒体哈希校验：内部 `assert_hash_valid`（`move/sources/orders.move:457`）强制 32 字节 BLAKE3 原始值，与链下媒体上传返回值互认。

## 3.5 S1/W1 — 质押与存储费
```move
// move/sources/staking.move:12-24
    public fun assert_min_credit(addr: address, required: u64) acquires CreditBook {
        if (!exists<CreditBook>(@haigo)) {
            return;
        };

        let book = borrow_global<CreditBook>(@haigo);
        if (!table::contains(&book.credits, addr)) {
            assert!(required == 0, error::invalid_state(E_INSUFFICIENT_CREDIT));
            return;
        };
        let credit = *table::borrow(&book.credits, addr);
        assert!(credit >= required, error::invalid_state(E_INSUFFICIENT_CREDIT));
    }
```
- `staking::assert_min_credit` 被订单创建、出库以及未来质押/信用流程复用，对应数据流 10.7 中的信用查询节点。
- 质押资产与信用记账未来将扩展 `CreditBook` 为结构体表，保持 Anchor 在 `move/sources/staking.move`。

### 3.5.1 Staking 扩展接口（已实现 初版）
- 质押/解押（仓库）：
  - `stake<CoinType>(warehouse: &signer, amount: u64)` — move/sources/staking.move:1
  - `unstake<CoinType>(warehouse: &signer, amount: u64)` — move/sources/staking.move:1
- 存储费设置：
  - `set_storage_fee(warehouse: &signer, fee_per_unit: u64)` — move/sources/staking.move:1

约束：
- 仅 `warehouse` 角色可调用（`registry::assert_role`）。
- `fee_per_unit ≤ 10000`（bps 上限），`amount > 0`。
- PoC 阶段仅链上记账，不做资金锁定；事件对外可见（见下）。

### 3.5.2 事件结构（已实现）
```move
struct StakeChanged has store, drop {
  warehouse: address,
  delta: u64,
  new_amount: u64,
  timestamp: u64,
}

struct StorageFeeUpdated has store, drop {
  warehouse: address,
  fee_per_unit: u64,
  timestamp: u64,
}
```
事件通过 `EventHandle<StakeChanged>` 与 `EventHandle<StorageFeeUpdated>` 暴露，供 Indexer/BFF 消费。

### 3.5.3 视图函数（已实现）
- `public fun get_stake(addr: address): u64` — 返回地址的当前质押仓位（move/sources/staking.move:1）。
- `public fun get_storage_fee(addr: address): u64` — 返回地址当前存储费（fee_per_unit）。

说明：链上视图为权威来源；BFF 读取视图失败时回落本地缓存（见《4-链下服务与数据流》）。

## 3.6 规划中模块与 Anchor 约定
- 理赔流程：`haigo::insurance` 模块将在 `move/sources/insurance.move（未来目标路径）` 定义 `Claim` 资源与 `ClaimOpened`/`ClaimResolved` 事件，支撑数据流 10.6；接口需预留 `assert_no_pending_claim(order_id)` 供出库前检查。
- 费率配置：`haigo::insurance_config` 负责保险费率/版本管理，Anchor 预留在 `move/sources/insurance_config.move（未来目标路径）`，供链下费率查询。
- 信用评分：`haigo::reputation` 将在 `move/sources/reputation.move（未来目标路径）` 定义评分快照与事件，用于数据流 10.7。

## 3.7 跨模块交互摘要
- 订单生命周期依赖注册与质押守卫（`registry::assert_role`、`staking::assert_min_credit`），未来需追加 `insurance::assert_no_pending_claim`；链上流程在 `orders::check_out` 中串联（`move/sources/orders.move:333-358`）。
- BFF 监听层需关注四类订单事件（`move/sources/orders.move:462-517`），并结合 Fullnode 事务信息生成统一时间线；对应实现详见《4-链下服务与数据流》。
- 单元测试覆盖在 `registry` 与 `orders` 文件尾部（例如 [`test_register_seller_success`](move/sources/registry.move:281)），可作为链下模拟与验收基线。
