# 3. 链上合约设计
| 模块 | 功能要点 | 实施状态 | 主要事件 |
|------|----------|----------|----------|
| `haigo::registry` | 角色注册（卖家/仓主/平台）、BLAKE3 哈希校验、事件追踪 | ✅ 已实现（Story 1.2） | `SellerRegistered`, `WarehouseRegistered`, `PlatformOperatorRegistered` |
| `haigo::orders` | 订单状态机、媒体存证、平台账户配置、信用校验 | ✅ 已实现（PoC 范围） | `OrderCreated`, `CheckedIn`, `SetInStorage`, `CheckedOut` |
| `haigo::staking` | 卖家信用最小值校验（`assert_min_credit`） | ✅ 已实现（辅助模块） | — |
| `haigo::insurance` | 理赔开启与赔付流程 | ⏳ 规划中（Epic 2） | `ClaimOpened`, `ClaimResolved`（规划） |
| `haigo::reputation` | 仓主评分与链下评价哈希 | ⏳ 规划中（Epic 3） | `RatingSubmitted`（规划） |

> 注：以下章节将已交付模块与规划模块分开展示，避免文档与当前代码偏离。

## 3.1 Registry 模块
### 状态结构
- `Registry` 资源部署在 `@haigo`，包含：
  - `accounts: table::Table<address, AccountRecord>`：以地址为键存储注册信息；
  - `seller_registered_events` / `warehouse_registered_events` / `platform_registered_events`: `EventHandle`；
- `struct AccountRecord { address: address, role: u8, hash_algorithm: u8, hash_value: String, timestamp: u64 }`。
- 角色与哈希算法常量通过 `role_seller()`、`role_warehouse()`、`role_platform_operator()`、`hash_algorithm_blake3()` 暴露，便于链下与其他模块引用。

### 关键入口函数
- `init_module(&signer)`：部署脚本调用一次，在 `@haigo` 下创建 `Registry` 资源。
- `register_seller` / `register_warehouse` / `register_platform_operator`：
  - 校验传入哈希为 64 字符小写十六进制且算法值为 BLAKE3；
  - 断言地址未注册；
  - 写入 `AccountRecord` 并记录当前 `timestamp::now_seconds()`；
  - 触发对应事件（包含 `sequence` 计数，用于链下去重）。
- `assert_role(addr, expected_role)`：供订单/后续模块调用，若地址未注册或角色不符，抛出 `E_ROLE_MISMATCH`。
- `is_registered`、`get_account_record`：`#[view]` 函数，链下可直接读取注册信息。

### 哈希与错误码
- `validate_hash` 确保：
  - 哈希算法常量为 `hash_algorithm_blake3()`；
  - 哈希字符串长度为 64，字符集限定 `0-9a-f`；
- 错误码：
  - `E_ALREADY_REGISTERED (1)`：重复注册；
  - `E_INVALID_HASH_FORMAT (3)`：长度或字符非法；
  - `E_ROLE_MISMATCH (5)`：`assert_role` 未通过；
  - `E_INVALID_ALGORITHM (4)`：未来用于扩展其他算法。

### 事件结构
- `SellerRegistered` / `WarehouseRegistered` / `PlatformOperatorRegistered` 字段：`address`, `role`, `hash_algorithm`, `hash_value`, `timestamp`, `sequence`。
- 事件由 `apps/bff/src/modules/accounts/event-listener.service.ts` 轮询消费，落地 `Account` 表并驱动 Story 1.4 API。

### 约束与交互
- 所有订单、质押相关入口函数都在链上调用 `registry::assert_role`，避免未注册主体操作。
- 平台部署脚本需先执行 `registry::init_module`，再发布其余模块。
- Move 单元测试覆盖：成功注册、重复注册失败、非法哈希、角色断言（见 `test_register_*` 用例）。

## 3.2 Orders 模块
### 状态结构
- `OrderBook` 资源（`@haigo` 持有）：
  - `orders: Table<u64, Order>`：按自增 ID 存储订单；
  - `next_order_id: u64`：自增主键；
  - `platform_account: address`：收款方 / 代办清关人员；
  - `timeline_enabled: bool` + `timeline_events: option::Option<vector<TimelineEntry>>`：可选时间线缓冲；
  - `order_created_events`、`checked_in_events`、`set_in_storage_events`、`checked_out_events`：事件句柄。
- `struct Order { id, seller, warehouse, status: u8, pricing: PricingRecord, logistics_inbound: Option<String>, logistics_outbound: Option<String>, created_at: u64, checked_in_at: Option<u64>, set_in_storage_at: Option<u64>, checked_out_at: Option<u64>, media_records: vector<MediaRecord>, insurance_blocked: bool }`。
- `struct PricingRecord { amount, insurance_fee, platform_fee, total, currency: TypeInfo }`。
- `struct MediaRecord { stage: u8, category: String, hash: vector<u8>, timestamp: u64 }`。
- `struct TimelineEntry { order_id: u64, status: u8, media_stage: Option<u8>, timestamp: u64 }` 用于启用时间线时的轻量缓存。

### 状态机流程与守卫
1. `create_order<CoinType>`（卖家签名）：
   - 调用 `registry::assert_role(seller, SELLER)` 与 `registry::assert_role(warehouse, WAREHOUSE)`；
  - `staking::assert_min_credit` 校验卖家信用（若信用簿不存在则跳过）；
  - 将 `amount + insurance_fee + platform_fee` 转入 `platform_account`；
  - 初始化 `Order`，允许选填初始媒体记录（stage=`MEDIA_STAGE_CREATED`）；
  - 记录 `created_at`，触发 `OrderCreated` 事件，必要时写入时间线。
2. `check_in`（仓主签名）：
  - 限制状态为 `ORDER_STATUS_CREATED` 且仓主地址匹配；
  - 写入入库物流编号、时间戳，追加 `MEDIA_STAGE_INBOUND` 媒体；
  - 触发 `CheckedIn` 事件。
3. `set_in_storage`（仓主签名）：
  - 仅在 `WAREHOUSE_IN` 状态下执行；
  - 追加 `MEDIA_STAGE_STORAGE` 媒体，记录时间戳；
  - 触发 `SetInStorage` 事件。
4. `check_out`（仓主或平台操作员签名）：
  - 要求状态为 `IN_STORAGE` 且 `insurance_blocked == false`；
  - 若操作员为仓主则校验仓主角色，否则校验平台角色；
  - 记录出库物流与 `MEDIA_STAGE_OUTBOUND` 媒体；
  - 触发 `CheckedOut` 事件。

其他守卫：
- 媒体哈希必须为 32 字节（BLAKE3 原始输出）；否则抛出 `E_INVALID_MEDIA_HASH`。
- Stage 与函数不匹配时抛出 `E_MEDIA_STAGE_MISMATCH`。
- 未找到订单或状态不符分别触发 `E_ORDER_NOT_FOUND`、`E_INVALID_STATUS_TRANSITION`。
- `insurance_blocked` 字段当前仅用于测试 helper，后续与理赔模块联动。

### 事件载荷
| 事件 | 字段摘要 |
|------|----------|
| `OrderCreated` | `order_id`, `seller`, `warehouse`, `pricing`（含 `currency` TypeInfo 与 `total`）, `logistics_inbound`, `timestamp`, `media` 向量 |
| `CheckedIn` | `order_id`, `warehouse`, `logistics_inbound`, `timestamp`, `media` |
| `SetInStorage` | `order_id`, `warehouse`, `timestamp`, `media` |
| `CheckedOut` | `order_id`, `operator`, `logistics_outbound`, `timestamp`, `media` |

### 3.2.4 媒体存证字段与约束
- 媒体阶段常量：`MEDIA_STAGE_CREATED (1)`、`INBOUND (2)`、`STORAGE (3)`、`OUTBOUND (4)`。
- `MediaRecord.hash` 为 32 字节向量，链下需将 64 字符十六进制解码为 `vector<u8>` 后再提交。
- `category` 自由文本（如 `inspection_photo`、`outbound_manifest`），用于链下标记展示顺序。
- `timestamp` 使用 `timestamp::now_seconds()`，便于索引器建立时间线。

### 3.2.5 费用与支付约束
- `PricingRecord.total = amount + insurance_fee + platform_fee`，链上写入一次后不会自动更新；
- `CoinType` 通过 `type_info::type_of<CoinType>()` 写入，PoC 测试采用 `haigo::mock_coin::MockCoin`；
- 当前版本未触发额外事件更新费用，后续若需动态调价将新增 `OrderPricingUpdated` 事件（规划）。

### 3.2.6 Story 对齐清单
| Story | 覆盖要点 | 备注 |
|-------|----------|------|
| 2.1 Order Lifecycle Move Module | 已实现的状态机函数、错误码、媒体约束提供直接基础。 | Epic 2 Story，文档提前规划，代码已具备核心骨架。 |
| 2.2 Order Creation & Fee Payment Flow | `create_order` 转账与定价逻辑、初始媒体校验。 | 订单 UI 尚未实现，链上接口可直接复用。 |
| 2.3 Inbound Media Upload & Hash Verification | `check_in` 的 stage 守卫与哈希验证。 | 需要链下 `/api/media/uploads` 支撑。 |
| 2.4 Fulfillment & Order Closure | `check_out` 权限判定、保险阻塞开关。 | 保险模块落地后才会启用 `insurance_blocked`。 |

### 3.2.7 测试覆盖
- `#[test]` 用例覆盖：
  - 成功流 `create_order → check_in → set_in_storage → check_out`；
  - 身份越权（卖家尝试 `check_in`、陌生地址 `check_out`）；
  - 状态跳跃（跳过入库直接出库）；
  - 媒体哈希长度错误。
- 测试借助 `registry::init_for_test`、`staking::set_credit`、`mock_coin` 工具快速构造上下文。

### 3.2.8 与链下协作要点
- 链下服务可通过 `get_order_summary` / `get_pricing` / `get_media` 直接读取最新状态。
- 当 `timeline_enabled` 为 true 时，可从 `timeline_events` 中批量消费状态变化，减轻事件回放压力。
- `order_id` 直接作为 `record_uid`，链下可根据业务需要格式化展示。

## 3.3 Staking 模块
### 当前实现
- `CreditBook` 资源维护 `credits: Table<address, u64>`（仅在测试或后台脚本中写入）。
- `assert_min_credit(addr, required)`：
  - 若 `CreditBook` 不存在则直接返回（表示暂不启用信用约束）；
  - 若地址无记录且 `required > 0`，抛出 `E_INSUFFICIENT_CREDIT`；
  - 若存在记录则比较额度，小于要求即抛错。
- `init_for_test`、`set_credit` 仅限单元测试/脚本调用，不会在生产环境公开。

### 演进方向
- Epic 2 计划引入实际质押资产、事件与奖励逻辑；届时会扩充结构并与 Reputation 模块联动。

## 3.4 规划模块（Insurance / Reputation）
### 3.4.1 `haigo::insurance`（规划）
- 目标：记录理赔申请、审批与赔付事件，并在订单出库前校验是否有未结案件。
- 当前状态：无代码实现，仅在 Story 2.x 中作为设计背景，后续交付前将更新本文档。

### 3.4.2 `haigo::reputation`（规划）
- 目标：聚合仓主/商家评分，将链下评价哈希写入链上并与质押权重挂钩。
- 当前状态：无代码实现，留待 Epic 3；本文将保持 Roadmap 描述。

## 3.5 模块交互与依赖关系
- Registry 提供基础身份验证，Orders/Staking 均依赖其角色常量；
- Orders 在创建阶段调用 Staking 校验信用额度，未来还将与 Insurance、Reputation 互通；
- BFF 通过 Indexer 监听 Registry/Orders 事件，结合 Prisma 存储供前端查询；
- 规划中的 Insurance 会反向设置 `orders::insurance_blocked`，Reputation 则影响 Staking 信用值。

## 3.6 权限与安全控制
- 模块发布：通过资源账户 `@haigo` 部署，需先执行 `registry::init_module` 再初始化其它模块；
- 访问控制：
  - Registry 入口函数仅允许签名者为自身地址；
  - Orders 限制仓主/平台角色，越权触发 `E_UNAUTHORIZED`；
- 错误码规范：
  - Registry：`E_ALREADY_REGISTERED`、`E_INVALID_HASH_FORMAT`、`E_ROLE_MISMATCH`；
  - Orders：`E_ALREADY_INITIALIZED`、`E_NOT_INITIALIZED`、`E_INVALID_STATUS_TRANSITION`、`E_INVALID_MEDIA_HASH`、`E_MEDIA_STAGE_MISMATCH`、`E_ORDER_NOT_FOUND`、`E_INSURANCE_BLOCKED`、`E_UNAUTHORIZED`；
  - Staking：`E_INSUFFICIENT_CREDIT`。
- 所有入口函数使用 `assert!` 与 `aptos_std::error`，确保链下可精确解析失败原因。

## 3.7 事件与索引策略
| 事件 | 当前消费方 | 说明 |
|------|------------|------|
| `SellerRegistered` / `WarehouseRegistered` / `PlatformOperatorRegistered` | BFF `AccountsEventListener` → Prisma `Account` 表 | Story 1.4 已上线，提供档案查询与哈希复核。 |
| `OrderCreated` / `CheckedIn` / `SetInStorage` / `CheckedOut` | （规划）Hasura / Order ingest 服务 | 订单 UI 尚未接入，事件格式已稳定，可用于后续索引。 |
| （规划）`ClaimOpened` / `ClaimResolved` | 待定 | 将在 Insurance 模块交付后补充。 |
| （规划）`RatingSubmitted` | 待定 | 将在 Reputation 模块交付后补充。 |

> 事件字段统一使用 `address`（参与方）、`String`（标签）、`vector<u8>`（哈希原始值）、`u64`（金额与时间），以便索引器统一解析。

## 3.8 测试与部署
- **单元测试：** `move/sources/registry.move` 与 `move/sources/orders.move` 含完整 `#[test]` 覆盖，执行 `pnpm --filter move test` 或 `move/scripts/run-tests.sh`。
- **构建：** `move/scripts/run-compile.sh` 编译全部模块；
- **部署脚本：** `move/scripts/deploy_registry.sh` 示例演示如何在本地或测试网上发布注册模块（后续会扩展到整包部署脚本）。
- **发布顺序建议：**
  1. 部署 `registry` 并初始化；
  2. 部署 `staking`（可选，若需信用守卫）；
  3. 部署 `orders` 并调用 `configure` 设置 `platform_account`；
  4. 更新前端 `packages/shared/src/config/aptos.ts` 与 BFF 环境变量。
- **升级策略：** 同步使用资源账户发布新包，升级前须运行 Move `compatibility_check`，确保结构未破坏现有账户资源。

