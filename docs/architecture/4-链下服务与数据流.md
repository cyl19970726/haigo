# 4. 链下服务与数据流

## 4.1 BFF / Indexer Ingest 管线
- **技术栈**：`apps/bff` 采用 NestJS + Express（`@nestjs/platform-express`），通过 `AppModule` 组合 Health 与 Accounts 模块，并由 `main.ts` 启动 HTTP 服务。
- **事件摄取**：`AccountsEventListener` 在模块初始化时读取 Aptos 官方 Indexer GraphQL，轮询 `0xHAIGO::registry::SellerRegistered` / `WarehouseRegistered` 事件，按 `txn_version + event_index` 去重后写入 Postgres。
- **服务责任**：
  1. 暴露账户档案查询与哈希复核接口，供前端注册页和运营工具调用。
  2. 聚合 Hasura 查询结果（订单数量等派生数据），补充到 REST 响应。
  3. （规划中）负责媒体上传与链下元数据持久化，保持与链上事件一致。

### 4.1.1 数据流概览
```mermaid
flowchart LR
  Move[Move 模块
SellerRegistered /
WarehouseRegistered] --> Indexer[Aptos 官方 Indexer
GraphQL]
  Indexer -->|poll| AccountsEventListener
  AccountsEventListener -->|upsert| Postgres[(Postgres
accounts 表)]
  Postgres --> Hasura[Hasura
tracked tables]
  Hasura --> AccountsService
  AccountsService -->|REST| AccountsAPI[GET/POST
/api/accounts/*]
  AccountsAPI --> WebApp[apps/web
Registration / Dashboard]
  WebApp -->|文件上传, 哈希复核| AccountsAPI
```

### 4.1.2 轮询与容错
- `AccountsEventListener` 实现 `OnModuleInit` / `OnModuleDestroy`，启动 `setInterval` 轮询；若一次循环尚未结束会跳过下一次触发，避免并发冲突。
- 事件查询使用常量 `REGISTRATION_EVENTS_QUERY`，带上游标参数：
  - `cursorVersion`、`cursorEventIndex`：来自最新成功处理事件。
  - `limit`：默认 50，可通过 `ACCOUNT_INGESTOR_PAGE_SIZE` 调整。
- 如 Indexer GraphQL 返回错误或网络失败会记录日志并进入下次周期，保持系统可恢复。

### 4.1.3 环境变量
| 变量 | 默认值 | 说明 |
|------|--------|------|
| `DATABASE_URL` | `postgres://postgres:postgres@localhost:5432/haigo` | Prisma/Postgres 连接串（PoC 在 Compose 中实际使用 `haigo:haigo@localhost:5433/haigo`） |
| `HASURA_URL` | `http://localhost:8080` | BFF 访问 Hasura GraphQL (`/v1/graphql` 自动拼接) |
| `APTOS_INDEXER_URL` | `https://indexer.testnet.aptoslabs.com/v1/graphql` | 官方 Indexer GraphQL 终端 |
| `ACCOUNT_INGESTOR_INTERVAL_MS` | `30000` | 事件轮询间隔（毫秒） |
| `ACCOUNT_INGESTOR_PAGE_SIZE` | `50` | 每次抓取事件条数 |
| `MEDIA_ROOT` | `./storage/media` |（规划）媒体文件存储根目录 |
| `MEDIA_MAX_FILE_MB` | `200` |（规划）上传大小限制，前端允许 200 MB 文档 |

## 4.2 数据模型定义
### 4.2.1 当前实现（accounts）
- 由 `apps/bff/prisma/migrations/20240610_create_accounts_table/` 创建，映射到 Prisma `Account` 模型。

| 列名 | 类型 | 说明 |
|------|------|------|
| `account_address` | `TEXT` (PK) | 注册账户地址，统一小写 hex |
| `role` | `AccountRole` (`seller`/`warehouse`) | 角色枚举 |
| `profile_hash_algo` | `TEXT` (默认 `blake3`) | 哈希算法标识 |
| `profile_hash_value` | `TEXT` | 64 位小写 hex 哈希值 |
| `profile_uri` | `TEXT` 可空 | 链下档案存储 URI（可选） |
| `registered_by` | `TEXT` | 触发注册的签名账户（通常与 `account_address` 相同） |
| `txn_version` | `BIGINT` | 事件交易版本 |
| `event_index` | `BIGINT` | 同一交易内事件索引 |
| `txn_hash` | `TEXT` | 便于追踪的交易哈希 |
| `chain_timestamp` | `TIMESTAMPTZ` | 区块时间戳 |
| `created_at` / `updated_at` | `TIMESTAMPTZ` | 由触发器自动维护 |

- 索引
  - `UNIQUE (txn_version, event_index)`：防止重复写入。
  - `INDEX (account_address)`：提供 API 主键查询。
  - 触发器 `set_accounts_updated_at` 保证更新时刷新 `updated_at`。

### 4.2.2 规划中的表
> 后续故事将引入以下实体，设计稿沿用原有约束，但实现时间尚未到来：
> `orders`、`order_events`、`staking_positions`、`claims`、`ratings`、`media_assets`。对应字段、索引设计可参考上一迭代版本或在 Story 开发时补充迁移脚本。

## 4.3 媒体存储策略
- **当前状态**：前端 `uploadIdentityDocument` 已预留调用 `POST /api/media/uploads`，但 BFF 尚未实现该端点；迭代中可先以 Mock 或前端内存缓存完成流程，Story 2.x 将补齐后端实现。
- **目标方案**：
  1. 采用本地磁盘或对象存储（阿里云 OSS）保存文件，路径规范：`{MEDIA_ROOT}/{record_uid}/{filename}`。
  2. BFF 接口负责二次计算 BLAKE3 哈希，与客户端上传前的哈希比对，若不一致直接拒绝写入。
  3. 将元数据写入 `media_assets` 表，字段包含 `record_uid`、`storage_path`、`hash_algo/value`、`mime_type`、`size_bytes`、`uploaded_by`。
  4. 提供静态或签名 URL 供前端回显，PoC 阶段可通过 Nginx 暴露 `MEDIA_ROOT` 目录。
- **限制**：图片 ≤ 15 MB，PDF/其他文档 ≤ 200 MB；与前端校验保持一致，配置由 `MEDIA_MAX_FILE_MB` 控制。

## 4.4 BFF API 接口规范
| 方法 | 路径 | 说明 | 请求示例 | 响应示例 |
|------|------|------|----------|----------|
| `GET` | `/api/accounts/:address` | 查询账户档案与派生统计（已实现） | `/api/accounts/0x1a2b...` | ```json
{
  "data": {
    "address": "0x1a2b",
    "role": "seller",
    "profileHash": { "algo": "blake3", "value": "..." },
    "profileUri": "ipfs://...",
    "registeredAt": "2024-06-12T10:00:00.000Z",
    "orderCount": 5
  },
  "meta": { "requestId": "...", "timestamp": "2024-06-12T10:05:00.000Z" }
}
``` |
| `POST` | `/api/accounts/:address/verify-hash` | 上传文件并复核 BLAKE3 哈希（已实现） | `multipart/form-data` 字段 `file` | ```json
{
  "data": {
    "address": "0x1a2b",
    "verified": true,
    "computedHash": "...",
    "storedHash": "...",
    "checkedAt": "2024-06-12T10:06:00.000Z"
  },
  "meta": { "requestId": "...", "timestamp": "2024-06-12T10:06:00.000Z" }
}
``` |
| `POST` | `/api/media/uploads` | 媒体上传（规划中） | `multipart/form-data`: `record_uid`, `role`, `hash`, `media` | ```json
{
  "data": {
    "recordUid": "HG-2024-0001",
    "path": "/media/HG-2024-0001/license.pdf",
    "hash": { "algo": "blake3", "value": "..." }
  },
  "meta": { "requestId": "...", "timestamp": "..." }
}
``` |

- 成功响应统一包裹在 `{ data, meta }`，并通过响应头 `x-haigo-trace-id` 暴露跟踪 ID。
- 错误响应遵循 Nest 默认 `HttpException` 结构 `{ statusCode, message, error }`；常见错误：
  - `400`：地址格式非法、缺少文件。
  - `404`：账户未找到。
  - `500`：外部服务（Hasura/Indexer）异常。

## 4.5 Hasura GraphQL 摘要
- 元数据位于 `hasura/metadata/`：
  - `databases/default/tables/public_accounts.yaml` 追踪 `accounts` 表并配置匿名/运营角色的列权限。
  - 预先声明的手动关系 `orders_by_creator`、`orders_by_warehouse` 将在订单表上线后自动生效。
- 查询集合 `query_collections/accounts.yaml` 提供公共查询 `accountByAddress`：
  ```graphql
  query accountByAddress($address: String!) {
    accounts_by_pk(account_address: $address) {
      account_address
      role
      profile_hash_value
      profile_uri
      txn_version
      event_index
      chain_timestamp
      orders_by_creator { record_uid }
      orders_by_warehouse { record_uid }
    }
  }
  ```
- 运行流程：
  1. 启动 Compose 后执行 `hasura metadata apply`（详见《docs/architecture/6-部署与环境.md》）。
  2. BFF 通过 `fetch` 调用 Hasura GraphQL，使用匿名角色获取订单聚合（见 `AccountsService.fetchOrderCount`）。
  3. 保持 Hasura 与 Prisma schema 同步：若新增字段需同时更新迁移与 metadata。

## 4.6 核心接口与类设计
- **AccountsService (`apps/bff/src/modules/accounts/accounts.service.ts`)**
  ```ts
  @Injectable()
  export class AccountsService {
    constructor(
      private readonly accountsRepository: AccountsRepository,
      private readonly configService: ConfigService,
    ) {}

    async getAccountProfile(address: string): Promise<AccountProfile> {
      const account = await this.accountsRepository.findByAddress(normalized);
      const profile = { ... };
      const orderCounts = await this.fetchOrderCount(normalized);
      return { ...profile, orderCount: orderCounts?.sellerCount ?? 0 };
    }

    async verifyProfileHash(address: string, file: Express.Multer.File) {
      const computedHash = bytesToHex(blake3(new Uint8Array(file.buffer))).toLowerCase();
      return { verified: computedHash === storedHash, computedHash, storedHash };
    }
  }
  ```
  - 负责聚合 Prisma 查询 + Hasura 聚合结果；哈希校验复用前端同一 `@noble/hashes` 库确保一致。

- **AccountsEventListener (`apps/bff/src/modules/accounts/event-listener.service.ts`)**
  ```ts
  const REGISTRATION_EVENTS_QUERY = gql`
    query RegistrationEvents($eventTypes: [String!], $limit: Int!, $cursorVersion: bigint!, $cursorEventIndex: Int!) {
      events(
        where: {
          type: { _in: $eventTypes }
          _or: [
            { transaction_version: { _gt: $cursorVersion } },
            {
              transaction_version: { _eq: $cursorVersion }
              event_index: { _gt: $cursorEventIndex }
            }
          ]
        }
        order_by: [{ transaction_version: asc }, { event_index: asc }]
        limit: $limit
      ) { ... }
    }
  `;

  async processEvent(event: RegistrationEventRecord) {
    const accountInput = this.mapEventToAccount(event);
    await this.accountsRepository.upsertFromEvent(accountInput);
    this.lastTxnVersion = accountInput.txnVersion;
    this.lastEventIndex = accountInput.eventIndex;
  }
  ```
  - `mapEventToAccount` 会解析事件 payload 中的 `profile_hash`、`profile_uri`，并校验哈希格式；
  - `upsertFromEvent` 内部比较现有版本号与新事件，保障幂等；
  - 轮询间隔、页大小通过 ConfigService 注入，可在测试中模拟。

- **AccountsRepository (`apps/bff/src/modules/accounts/accounts.repository.ts`)**
  - 封装 Prisma 访问；`upsertFromEvent` 会跳过旧事件（`existing.txnVersion > incoming`）。
  - 默认写入 `profileHashAlgo = 'blake3'`，统一大小写。

- **测试覆盖**：`apps/bff/test/accounts.integration.spec.ts` 使用 Mock Prisma + Mock fetch 验证“事件 → 存储 → API”完整链路；Story 1.4 交付要求全部满足。

---

> ✅ 本节内容与当前仓库实现保持一致；如后续迭代新增订单、理赔等模块，请同步更新 4.2、4.4、4.6 对应表格与代码示例。

## 4.7 订单生命周期数据管线计划
为实现 Epic 2 的链上订单状态机与链下媒体存证闭环，需在现有 BFF/数据库/Hasura 基础上扩展如下能力。

### 4.7.1 事件→数据流拓扑
```mermaid
flowchart LR
  subgraph OnChain
    OC[hai_go::orders events]
  end
  subgraph Indexing
    IDX[Aptos Indexer GraphQL]
    EVT[OrdersEventListener]
  end
  subgraph Storage
    DB[(Postgres: orders / order_events / order_media_assets)]
    HAS[Hasura metadata & views]
  end
  subgraph Services
    ORD[OrdersService + Repository]
    MED[MediaRepository]
  end
  subgraph Clients
    API[REST /api/orders]
    Web[apps/web Orders & Claims]
    MediaAPI[REST /api/media/uploads]
  end

  OC --> IDX --> EVT --> DB --> HAS --> ORD --> API --> Web
  ORD --> MED
  Web -->|upload media| MediaAPI
  MediaAPI --> MED
  MED --> DB
```

- 轮询仍使用官方 Indexer GraphQL，事件类型：`0xHAIGO::orders::OrderCreated`、`CheckedIn`、`SetInStorage`、`CheckedOut`。
- OrdersEventListener 独立维护游标表 `order_event_cursor`（`txn_version`、`event_index`），避免与账户监听互相影响。
- 事件处理后既更新 `orders` 主表，也追加 `order_events` 时间线记录；媒体哈希字段写入 `order_media_assets`。

### 4.7.2 数据模型拓展
新增 Prisma 模型与数据库迁移（示例字段如下，最终以 Story 2.1/2.3 实现为准）：

| 表 | 主键 | 关键字段 | 说明 |
|----|------|----------|------|
| `orders` | `order_id` (`BIGINT`) | `record_uid`, `seller_address`, `warehouse_address`, `status`, `pricing_currency`, `pricing_amount`, `insurance_fee`, `logistics_id`, `created_at`, `checked_in_at`, `storage_set_at`, `checked_out_at`, `last_txn_version`, `last_event_index` | 主视图；`record_uid` 供前端展示（规则：`HG-{yyyy}{sequence}` 或直接使用链上 `order_id`）。
| `order_events` | `id` (`SERIAL`) | `order_id`, `event_type`, `actor_address`, `payload_json`, `media_hashes`, `logistics_id`, `txn_version`, `event_index`, `chain_timestamp` | 时间线明细；`UNIQUE (txn_version, event_index)`。
| `order_media_assets` | `id` (`SERIAL`) | `order_id`, `event_type`, `hash_algo`, `hash_value`, `storage_path`, `size_bytes`, `uploaded_by`, `source` (`enum: onchain/offchain`) | 连接链上哈希与链下文件；`hash_value` 索引用于比对。
| `order_event_cursor` | `singleton` | `last_txn_version`, `last_event_index`, `updated_at` | 订单监听游标持久化（也可通过 `orders` 表最大值推导，保留单行更直观）。

约束与派生规则：
- `orders.status` 从事件推导，事件顺序必须符合状态机：`ORDER_CREATED → WAREHOUSE_IN → IN_STORAGE → WAREHOUSE_OUT`，若违反则记录异常并跳过写入。
- `order_events.media_hashes` 存储链上事件提供的哈希向量（`vector<HashValue>`），在 `order_media_assets` 中匹配 `hash_value`；位置字段用于 UI 展示。
- 通过 Hasura 手动关系：`orders` ↔ `order_events` (1:N)、`order_events` ↔ `order_media_assets` (1:N)，并与 `accounts` 建立外键关系以查询角色资料。

### 4.7.3 BFF 模块设计
- 新增 `apps/bff/src/modules/orders/`：包含 `orders.module.ts`、`orders.controller.ts`、`orders.service.ts`、`orders.repository.ts`、`orders-event-listener.service.ts`。
- `OrdersRepository`
  - `upsertOrderFromEvent(event)`：根据事件类型更新主表字段，维护状态与时间戳。
  - `appendTimeline(event)`：写入 `order_events`，并关联媒体哈希。
  - `attachMedia(recordUid, payload)`：结合 `/api/media/uploads` 返回的存储路径，将链下媒体入库。
- `OrdersService`
  - `getOrder(recordUid)`：聚合 Prisma + Hasura + 本地媒体。
  - `listOrders(filter)`：分页过滤（地址、状态、日期范围）。
  - `verifyMediaHash(recordUid, hash)`：与 `order_media_assets` 对比并返回一致性结果。
- `OrdersEventListener`
  - 与账户监听共用 ConfigService，但拥有独立轮询配置（`ORDER_INGESTOR_INTERVAL_MS`、`ORDER_INGESTOR_PAGE_SIZE`）。
  - 处理顺序：解析事件 → 验证哈希格式 → 更新主表/时间线 → 同步游标。

### 4.7.4 API 规划
| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| `GET` | `/api/orders` | 列表查询 | 支持 `seller`, `warehouse`, `status`, `cursor`, `pageSize` 参数；默认返回近期 50 条。 |
| `GET` | `/api/orders/:recordUid` | 详情聚合 | 返回订单主信息、时间线、媒体资源、索赔/质押引用（预留字段）。 |
| `POST` | `/api/orders/:recordUid/media-verify` | 媒体哈希校验 | 输入 `hash_value` 或上传文件，与 `order_media_assets` 比对；用于入库/出库节点重检。 |
| `POST` | `/api/orders/:recordUid/media-link` | 绑定链下媒体（计划） | 前端调用 `/api/media/uploads` 后将 `storage_path` 与哈希回写，便于运营或后续审核。 |

返回数据遵循 `{ data, meta }` 包装；`OrderSummary`/`OrderTimelineItem` DTO 放置在 `packages/shared/src/dto/orders.ts`。

### 4.7.5 媒体存证协同
- `POST /api/media/uploads` 成功后立即写入 `media_assets`，并返回 `hash`、`storagePath`、`recordUid`；前端在提交链上交易前缓存该响应。
- 事件触发后，OrdersEventListener 根据链上 `media_hashes` 字段检索 `order_media_assets`；
  - 若找到同哈希则将 `source` 标记为 `onchain+offchain`，表示已匹配；
  - 若未找到，则创建占位记录（仅含 `hash_algo/value`，`storage_path` 为空），提示运营补录。
- 提供周期性任务或手动 API 修补缺失的链下媒体，确保订单时间线每个节点都有可验证证据。

### 4.7.6 实施顺序建议
1. **数据库迁移**：定义 `orders`、`order_events`、`order_media_assets`、`order_event_cursor` 及相关索引/触发器。
2. **Prisma & DTO 更新**：生成 Prisma client、编写共享 DTO、更新 `packages/shared`。
3. **Hasura Metadata**：追踪新表、配置权限与关系、添加常用查询（订单列表/详情）。
4. **OrdersEventListener**：实现事件轮询、游标管理、幂等 upsert，编写集成测试（模拟 Indexer 响应）。
5. **OrdersService + API**：实现 REST 控制器、列表/详情/校验接口，并补齐单元测试。
6. **媒体联动**：扩展 `/api/media/uploads` 与 `OrderMediaAssets` 绑定逻辑，确保链上哈希与链下文件一致。
7. **前端对接**：更新 `apps/web` features/orders，实现 Story 2.2–2.4 所需的数据消费与媒体验证流程。

按此顺序推进可在每个阶段交付可验证的增量能力，同时保持 PoC 环境的可演示性。

### 4.7.7 与 Epic 2 Story 对齐项
| Story | 架构交付要点 | 文档位置 |
|-------|--------------|----------|
| 2.1 Order Lifecycle Move Module | Off-chain 需要监听四类事件、验证状态序列、落库订单主视图与时间线；提供游标持久化和幂等写入策略；准备 `OrderSummary` DTO 供 Web/BFF 共用。 | §4.7.1、§4.7.2、§4.7.3、§4.7.4 |
| 2.2 Order Creation & Fee Payment Flow | BFF 列表/详情接口支撑商家端展示；`OrdersService.listOrders` 支持费用拆解字段、汇总 `pricing_amount` 与 `insurance_fee`；Hasura/Prisma 同步 `pricing_currency`。 | §4.7.3 `listOrders`、§4.7.4 第1行、§4.7.2 `orders` 表说明 |
| 2.3 Inbound Media Upload & Hash Verification | `/api/orders/:recordUid/media-verify` + `/api/media/uploads` 联动；`order_media_assets` 记录入库节点媒体哈希，`source` 字段区分链上/链下，提供缺失占位逻辑。 | §4.7.3 `attachMedia`、§4.7.4 第3、4行、§4.7.5 |
| 2.4 Fulfillment & Order Closure | 时间线事件记录出库物流信息；BFF 详情接口返回完整流程；媒体匹配流程与 Story 2.3 共用；Hasura 订阅或轮询刷新统计。 | §4.7.2 `order_events` 字段、§4.7.3 `upsertOrderFromEvent`、§4.7.4 第2行 |

### 4.7.8 前端/后端数据契约扩展
- **共享 DTO (`packages/shared/src/dto/orders.ts`)**（计划新增）
  ```ts
  export interface OrderSummary {
    recordUid: string;
    orderId: string;
    status: 'ORDER_CREATED' | 'WAREHOUSE_IN' | 'IN_STORAGE' | 'WAREHOUSE_OUT';
    seller: string;
    warehouse: string;
    pricing: {
      currency: string;
      amount: string; // 保留精度，使用字符串表示 Octas
      insuranceFee?: string;
    };
    logisticsId?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface OrderTimelineItem {
    type: 'OrderCreated' | 'CheckedIn' | 'SetInStorage' | 'CheckedOut';
    actor: string;
    occurredAt: string;
    logisticsId?: string;
    mediaHashes: Array<{ algo: 'blake3'; value: string; matchedOffchain: boolean }>;
    payload: Record<string, unknown>;
    txnVersion: string;
    eventIndex: number;
  }

  export interface OrderDetail extends OrderSummary {
    timeline: OrderTimelineItem[];
    mediaAssets: Array<{
      hash: { algo: 'blake3'; value: string };
      storagePath?: string;
      uploadedBy?: string;
      sizeBytes?: number;
      source: 'onchain' | 'offchain' | 'onchain+offchain';
    }>;
  }
  ```
- **BFF → Web 接口约定**：REST 响应继续包裹 `{ data, meta }`，`meta` 内包含 `requestId`、`timestamp`、可选 `cursor`。
- **错误码扩充**：新增 `E_ORDER_NOT_FOUND`、`E_ORDER_STATUS_CONFLICT`、`E_MEDIA_HASH_MISMATCH`，由 BFF 映射到 `404/409/422`。

### 4.7.9 运行与测试要求
- **自动化测试**：
  - 集成测试模拟 Indexer 事件（创建→入库→出库），断言 `orders`/`order_events`/`order_media_assets` 三表写入及 API 返回结构。
  - `/api/orders/:recordUid/media-verify` 上传文件时复用 BLAKE3 逻辑，确保 200 MB 文件在测试环境下通过内存流式处理或分块方案。
- **工具脚本**：
  - `scripts/seed-orders.ts`（计划）可插入模拟事件，加速本地调试。
  - `scripts/backfill-order-media.ts` 支持运营根据哈希补上传缺失媒体。
- **监控指标**：
  - `order_listener_last_version`：最近一次处理的链上版本，用于告警。
  - `order_listener_error_total`：轮询失败次数。
  - `order_media_missing_total`：缺失链下媒体的订单节点数量。

### 4.7.10 后续演进关注
- 订单与质押/理赔的联动（Story 3.x）需要在 `OrderDetail` 中预留关联字段（`claimIds`, `stakeSnapshotWeight`）。
- 当引入自建 Indexer Processor 时，可将 `orders` 与 `order_events` 落地任务迁移至 Processor，BFF 仅提供查询；当前方案保持直接轮询，PoC 阶段足够。
- 若媒体资产迁移至 OSS，需在 `order_media_assets` 增加 `presigned_url`、`expires_at` 字段，并扩展 `/api/media/uploads` 返回值。
