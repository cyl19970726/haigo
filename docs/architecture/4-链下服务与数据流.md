# 4. 链下服务与数据流
## 4.1 BFF / Media Ingestor
- 技术栈：NestJS/Fastify + TypeScript。
- 责任：
  1. 生成订单、质押等前端需要的派生数据端点（聚合 Aptos Indexer API 与本地 Postgres/Hasura 数据）。
  2. 处理媒体上传：
     - 验证 MIME/大小（图片 ≤15 MB，视频 ≤200 MB）。
     - 计算 `blake3` 哈希并写入 Postgres `media_assets`（PoC 可用 JSON 存储）。哈希输出固定为 256-bit，下游统一保存为 64 位小写十六进制字符串。
     - 保存到本地路径 `media://{record_uid}/{filename}`，对外通过 Nginx/静态服务公开。
  3. 提供链下哈希复核接口，允许运营或用户重新校验媒体。

- 直接复用 Aptos Labs 托管的 Indexer GraphQL API（`https://api.<network>.aptoslabs.com/v1/graphql`）获取基础链上数据：账户信息、可替代资产余额、通用交易历史等。借助 `where` 子句即可筛选 HaiGo 自定义 Move 事件，例如按 `type = "0xHAIGO::orders::CheckedIn"` 获取订单时间线。
- `apps/bff` 基于该 GraphQL API 封装常用查询（订单事件、质押快照、理赔记录、评分列表），并负责与本地媒体元数据合并，向前端提供统一的 REST/GraphQL 接口。
- 仅当需要长期保留快照或复杂聚合（运营报表、离线分析）时，再引入 Aptos Build No-Code Indexer Processor，将事件落地到 `docs/architecture/indexer-schema.md` 中定义的表结构。PoC 阶段可暂缓自建 Processor，专注官方 Indexer + BFF 聚合，实现最小可行链上数据闭环。

## 4.2 数据模型定义
- **总体原则**：链下数据全部集中在 Postgres，Hasura 作为 GraphQL BFF 暴露结构化查询；所有链上事件均以 `txn_version + event_index` 去重，并保留 `chain_timestamp` 便于回放。
- **核心实体（PoC 范围）**：

  | 表名 | 主键/索引 | 关键字段 | 说明 |
  |------|-----------|----------|------|
  | `accounts` | PK: `account_address`；唯一索引 `(txn_version, event_index)` | `role`, `profile_hash_algo`, `profile_hash_value`, `profile_uri` | 映射注册事件，区分商家/仓主身份，后续可追加 KYC 元数据。`profile_hash_algo` 当前固定为 `blake3`，`profile_hash_value` 必须是 64 位小写十六进制字符串。 |
  | `orders` | PK: `record_uid`；索引 `creator_address`, `warehouse_address`, `status` | `status`, `storage_fee`, `insurance_fee`, `last_media_hash_*`, `logistics_*` | 代表订单主视图，`last_*` 字段跟踪最新链上状态与媒体哈希。 |
  | `order_events` | PK: `id`（序列）；唯一索引 `(txn_version, event_index)`；索引 `record_uid` | `event_type`, `media_hash_*`, `logistics_no`, `payload` | 保存订单时间线的每一次状态变更，`payload` 存储事件原始 JSON。 |
  | `staking_positions` | PK: `id`；唯一索引 `(txn_version, event_index)`；索引 `owner_address` | `asset_type`, `total_amount`, `credit_weight` | 质押事件快照，BFF 通过 `ORDER BY txn_version DESC` 获取最新值。 |
  | `claims` | PK: `claim_id`；唯一索引 `(last_event_version, last_event_index)`；索引 `record_uid` | `status`, `payout_amount`, `payout_currency`, `evidence_hash_*`, `resolution_hash_*` | 理赔流程主表，支持按订单维度聚合查询。 |
  | `ratings` | PK: `id`；唯一索引 `(txn_version, event_index)`；索引 `warehouse_address` | `score`, `review_hash_*`, `record_uid` | 仓主评分记录，支撑信用榜单与反馈抽样。 |
  | `media_assets` | PK: `id`；唯一索引 `(record_uid, storage_path)`；索引 `hash_value`, `owner_address` | `storage_path`, `hash_algo`, `hash_value`, `mime_type`, `size_bytes`, `uploaded_by` | 链下媒体元数据，与本地磁盘路径或未来 OSS 对象一一映射，`hash_value` 支撑查重与重新校验。 |

- **关系约束**：
  - `orders.record_uid` ↔ `order_events.record_uid`（1:N）、`claims.record_uid`、`ratings.record_uid`，用于订单详情聚合。
  - `accounts.account_address` 与 `orders.creator_address`、`orders.warehouse_address` 建立 Hasura 手动关系，便于查询身份信息。
  - `media_assets.record_uid` 可选外键到 `orders.record_uid`，PoC 阶段通过应用层校验以避免硬依赖。
  - 注册表相关链上事件必须输出符合上述哈希格式的数据，否则链下消费会直接拒绝写入。

- **Hasura 配置要点**：追踪上述表后，将 `orders.status`、`claims.status`、`order_events.event_type` 以 enum mapping 暴露，更利于前端消费；匿名角色仅开放 `select` 查询，运营角色开放 `aggregate` 与媒体检索。
- **扩展指引**：如需引入自建 Indexer Processor，请复用 `docs/detail/indexer-schema.md` 中的完整 DDL；未来引入 OSS 时，在 `media_assets` 增加 `storage_provider`, `bucket`, `object_key`。数据保留策略初期以 90 天回溯为界，后续结合监管要求调整。

## 4.3 媒体存储策略
- PoC：本地磁盘 + 定期 rsync 备份。
- 预留接口 `StorageProvider`：未来切换到阿里云 OSS（SSE-KMS、生命周期管理、访问日志）。

## 4.4 BFF API 接口规范
| Method | Path | 说明 | 请求参数 | 响应示例 |
|--------|------|------|----------|----------|
| `GET` | `/api/accounts/:address` | 返回地址对应的商家/仓主档案、注册哈希及订单统计 | `address`：Aptos 地址 | `{ "address": "0x...", "role": "seller", "profileHash": { "algo": "blake3", "value": "..." }, "registeredAt": "2025-09-15T12:30:00Z", "orderCount": 4 }` |
| `POST` | `/api/media/uploads` | 处理媒体上传；PoC 直接写本地磁盘，返回存储路径与哈希 | `multipart/form-data`：`record_uid`, `media` | `{ "recordUid": "HG-202509-0001", "path": "/media/HG-202509-0001/inbound-1.jpg", "hash": { "algo": "blake3", "value": "..." } }` |
| `GET` | `/api/orders/:record_uid` | 聚合订单当前状态、时间线、媒体哈希验证结果 | `record_uid` | `{ "recordUid": "HG-202509-0001", "status": "WAREHOUSE_IN", "timeline": [...], "hashVerified": true }` |
| `GET` | `/api/orders` | 支持分页与筛选的订单列表，供运营/商家看板使用 | Query：`role`, `warehouseAddress`, `status`, `limit`, `cursor` | `{ "data": [...], "nextCursor": "..." }` |
| `GET` | `/api/staking/:address` | 返回仓主质押额度与信用权重快照 | `address` | `{ "owner": "0x...", "assetType": "0x1::aptos_coin::AptosCoin", "totalAmount": "1200", "creditWeight": "0.85", "updatedAt": "2025-09-16T02:20:00Z" }` |
| `GET` | `/api/claims/:record_uid` | 订单关联的理赔状态列表 | `record_uid` | `{ "recordUid": "HG-202509-0001", "claims": [{ "claimId": "CLM-01", "status": "OPEN", "evidenceHash": "..." }] }` |

接口统一返回 `meta.requestId`、`meta.timestamp` 字段，错误响应遵循 `code/message/details` 格式，并在响应头附带 `x-haigo-trace-id` 以便前端追踪。

## 4.5 Hasura GraphQL 摘要
- `query accountByAddress($address: String!)`：从 `accounts` 表读取角色与档案哈希。
- `query ordersByCreator($creator: String!, $limit: Int)`：基于 `orders` + `order_events` 关系返回订单及时间线。
- `query stakingHistory($owner: String!, $limit: Int = 20)`：分页查询 `staking_positions` 快照。
- `query claimsByRecord($recordUid: String!)`：拉取 `claims` 表及最新状态字段。

Hasura Metadata 设置：
1. 为上述查询定义 `Query Collection`，供前端与 BFF 重用。
2. `anonymous` 角色开放只读查询（可通过 `allow_aggregations=false` 限制聚合）。
3. `operations` 角色允许 `aggregate` 与复杂过滤，用于运营看板。

## 4.6 核心接口与类设计
- **共享类型（`packages/shared/src/dto`）**：以 TypeScript interface 表达链上/链下统一数据模型，供前端与 BFF 复用。

```ts
export type OrderStatus = 'ORDER_CREATED' | 'WAREHOUSE_IN' | 'IN_STORAGE' | 'WAREHOUSE_OUT';

export interface AccountProfile {
  address: string;
  role: 'seller' | 'warehouse';
  profileHash: { algo: 'blake3'; value: string };
  profileUri?: string;
  registeredAt: string; // ISO timestamp
}

export interface OrderTimelineEvent {
  recordUid: string;
  type: OrderStatus;
  chainVersion: number;
  chainIndex: number;
  occurredAt: string;
  mediaHash?: { algo: 'blake3'; value: string };
  logisticsNo?: string;
  payload?: Record<string, unknown>;
}

export interface OrderSummary {
  recordUid: string;
  creator: string;
  warehouse: string;
  status: OrderStatus;
  storageFee: string;
  insuranceFee: string;
  lastMediaHash?: { algo: string; value: string };
  logisticsInboundNo?: string;
  logisticsOutboundNo?: string;
  timeline: OrderTimelineEvent[];
}

export interface StakingSnapshot {
  owner: string;
  assetType: string;
  totalAmount: string;
  creditWeight?: string;
  updatedAt: string;
}

export interface ClaimRecord {
  claimId: string;
  recordUid: string;
  status: 'OPEN' | 'RESOLVED' | 'REJECTED';
  payoutAmount?: string;
  payoutCurrency?: string;
  evidenceHash?: { algo: string; value: string };
  resolutionHash?: { algo: string; value: string };
  updatedAt: string;
}

export interface RatingRecord {
  id: string;
  warehouse: string;
  rater: string;
  recordUid: string;
  score: 1 | 2 | 3 | 4 | 5;
  reviewHash?: { algo: string; value: string };
  submittedAt: string;
}

export interface MediaAssetMeta {
  id: string;
  recordUid: string;
  storagePath: string;
  hash: { algo: string; value: string };
  mimeType: string;
  sizeBytes: number;
  uploadedBy: string;
  uploadedAt: string;
}
```

- **BFF 服务分层（`apps/bff/src/modules`）**：每个领域模块暴露 Controller（HTTP GraphQL）、Service（业务组合）与 Repository（数据访问）三层。

```ts
// apps/bff/src/modules/orders/orders.service.ts
@Injectable()
export class OrdersService {
  constructor(
    private readonly indexerRepo: OrdersIndexerRepository,
    private readonly hasuraRepo: OrdersHasuraRepository,
    private readonly mediaRepo: MediaRepository,
  ) {}

  async getOrder(recordUid: string): Promise<OrderSummary> {
    const [order, events, media] = await Promise.all([
      this.indexerRepo.fetchOrder(recordUid),
      this.indexerRepo.fetchTimeline(recordUid),
      this.mediaRepo.listByRecord(recordUid),
    ]);
    return mapOrderAggregate(order, events, media);
  }

  async listOrders(filter: ListOrdersFilter): Promise<Paginated<OrderSummary>> {
    return this.hasuraRepo.queryOrders(filter);
  }
}

// apps/bff/src/modules/media/media.repository.ts
@Injectable()
export class MediaRepository {
  constructor(private readonly prisma: PrismaService) {}

  async listByRecord(recordUid: string): Promise<MediaAssetMeta[]> {
    return this.prisma.mediaAsset.findMany({ where: { recordUid } });
  }
}
```

- **前端特性模块（`apps/web/features`）**：以“页面入口 + hooks + 组件”组织，每个特性依赖共享 DTO 与轻量查询客户端。
  - `features/orders`：订单详情页 `OrderDetailPage.tsx`，调用 `useOrder(recordUid)` Hook（封装自 BFF REST/GraphQL + DTO 类型）。
  - `features/staking`：质押榜单组件 `StakingLeaderboard.tsx`，消耗 `StakingSnapshot[]`。
  - `features/claims`：理赔状态面板，复用 `ClaimRecord`。

- **Move 脚本接口**：`move/scripts/deploy.mjs` 暴露 `deployModules(env): Promise<DeployedAddresses>`，将模块地址写回 `packages/shared/src/config/aptos.ts`，供前后端统一引用。
