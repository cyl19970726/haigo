# 4. 链下服务与数据流

> 本章节聚焦 BFF（`apps/bff`）在各场景下的职责划分、模块 Anchor、核心代码与未来扩展。相较于早期版本，本设计补齐 Fullnode 事务兜底与 BFF 内部数据流，确保与《10-场景化端到端数据流》一致。

## 4.1 模块锚点索引
| 区域 | Anchor | 实施状态 | 覆盖场景 |
|------|--------|----------|----------|
| Nest 入口 | `apps/bff/src/main.ts:6` | ✅ | 全部 |
| 配置中心 | `apps/bff/src/common/configuration.ts:1` | ✅ | 全部 |
| Prisma 基础设施 | `apps/bff/src/infrastructure/prisma/prisma.service.ts:1` | ✅ | 全部 |
| `AccountsModule` | `apps/bff/src/modules/accounts/accounts.module.ts:1` | ✅ | R1、R2 |
| `AccountsEventListener` | `apps/bff/src/modules/accounts/event-listener.service.ts:15` | ✅ | R1 |
| `AccountsController` | `apps/bff/src/modules/accounts/accounts.controller.ts:24` | ✅ | R1、R2 |
| `AccountsService` | `apps/bff/src/modules/accounts/accounts.service.ts:17` | ✅ | R1、R2 |
| `MediaModule` | `apps/bff/src/modules/media/media.module.ts:1` | ✅ | O2（链下媒体） |
| `MediaService` | `apps/bff/src/modules/media/media.service.ts:29` | ✅ | O2（上传），R2（校验） |
| Fullnode 客户端 | `apps/bff/src/modules/fullnode/fullnode.module.ts`（未来目标路径） | 🚧 | R1–S1 事务兜底 |
| 订单监听模块 | `apps/bff/src/modules/orders/orders.module.ts:1`、`apps/bff/src/modules/orders/orders.controller.ts:1`、`apps/bff/src/modules/orders/orders.service.ts:1`、`apps/bff/src/modules/orders/orders-event-listener.service.ts:1` | ✅ 初版 | O1、O2 |
| 理赔模块 | `apps/bff/src/modules/claims/claims.module.ts`（未来目标路径） | 🚧 | C1 |
| 质押 & 信用模块 | `apps/bff/src/modules/staking/staking.module.ts`（未来目标路径） | 🚧 | S1 |

## 4.2 基础设施与运行时
- **配置装载**：`configuration`（`apps/bff/src/common/configuration.ts:1-17`）统一暴露 `indexerUrl`、`nodeApiUrl`（未来 Fullnode 客户端读取）、`ingestion.pollingIntervalMs` 等参数。
- **Prisma 连接**：`PrismaService`（`apps/bff/src/infrastructure/prisma/prisma.service.ts:5-26`）在 `onModuleInit` 建立连接，所有仓储层统一依赖此服务。
- **数据库 Schema**：`apps/bff/prisma/schema.prisma:10-55` 定义 `Account` 与 `MediaAsset` 表，确保与链下存储结构、时间线需求一致。

## 4.3 R1 — 注册事件同步
### 4.3.1 监听流程
```ts
// apps/bff/src/modules/accounts/event-listener.service.ts:15-45
const REGISTRATION_EVENTS_QUERY = /* GraphQL */ `
  query RegistrationEvents(
    $eventTypes: [String!]
    $limit: Int!
    $cursorVersion: bigint!
    $cursorEventIndex: bigint!
  ) {
    events(
      where: {
        type: { _in: $eventTypes }
        _or: [
          { transaction_version: { _gt: $cursorVersion } }
          {
            transaction_version: { _eq: $cursorVersion }
            event_index: { _gt: $cursorEventIndex }
          }
        ]
      }
      order_by: [{ transaction_version: asc }, { event_index: asc }]
      limit: $limit
    ) {
      transaction_version
      event_index
      type
      data
      transaction_hash
      account_address
      transaction_timestamp
    }
  }
`;
```
```ts
// apps/bff/src/modules/accounts/event-listener.service.ts:94-122
private async pollOnce(): Promise<void> {
  if (this.isPolling) {
    this.logger.warn('Skip poll tick because previous cycle is still running');
    return;
  }
  this.isPolling = true;
  try {
    let hasMore = true;
    while (hasMore) {
      const events = await this.fetchRegistrationEvents();
      if (events.length === 0) {
        hasMore = false;
        break;
      }
      for (const event of events) {
        await this.processEvent(event);
      }
      hasMore = events.length === this.pageSize;
    }
  } catch (error) {
    this.logger.error('Failed to poll registration events', error instanceof Error ? error.stack : error);
  } finally {
    this.isPolling = false;
  }
}
```
- `fetchRegistrationEvents` 调用 Indexer GraphQL，参数 `cursorVersion`、`cursorEventIndex` 对应数据流 10.2 的循环游标。
- `processEvent` 内部映射为 `AccountUpsertInput`，并调用 `AccountsRepository.upsertFromEvent`（`apps/bff/src/modules/accounts/accounts.repository.ts:42-63`）。

### 4.3.2 数据落地
```ts
// apps/bff/src/modules/accounts/accounts.repository.ts:84-111
private mapInputToCreate(input: AccountUpsertInput): Prisma.AccountCreateInput {
  return {
    accountAddress: input.accountAddress,
    role: this.toAccountRole(input.role),
    profileHashAlgo: 'blake3',
    profileHashValue: input.profileHashValue,
    profileUri: input.profileUri ?? null,
    registeredBy: input.registeredBy,
    txnVersion: input.txnVersion,
    eventIndex: input.eventIndex,
    txnHash: input.txnHash,
    chainTimestamp: input.chainTimestamp
  };
}
```
- `Account` 表联合唯一索引（`apps/bff/prisma/schema.prisma:29`）保证事件幂等，游标在 Listener 启动时通过 `getLatestProcessedEvent` 恢复。

### 4.3.3 API 暴露
- `GET /api/accounts/:address`（`apps/bff/src/modules/accounts/accounts.controller.ts:28-38`）调用 `AccountsService.getAccountProfile`。
- `AccountsService` 在 `getAccountProfile` 内部通过 Hasura（`apps/bff/src/modules/accounts/accounts.service.ts:87-137`）补充订单计数。
- 统一附加响应头 `x-haigo-trace-id` 便于链路追踪。

### 4.3.4 POC 临时兜底（Fullnode by_version）
- 背景：部分 Indexer 实例不暴露 `transaction_hash` 字段，导致轮询失败。
- 方案：在 `AccountsEventListener` 内联调用 Fullnode REST `GET /transactions/by_version/{version}` 获取 `hash` 与 `timestamp`。
- Anchor：`apps/bff/src/modules/accounts/event-listener.service.ts`（`resolveTxnMetaByVersion` 与 `processEvent` 中的兜底分支）。
- 备注：后续若扩展到订单/理赔监听，再抽象为独立 `FullnodeSyncService`。

## 4.4 R2 — 档案哈希校验
```ts
// apps/bff/src/modules/accounts/accounts.service.ts:61-85
async verifyProfileHash(address: string, file: Express.Multer.File) {
  if (!file) {
    throw new BadRequestException('Verification file is required');
  }
  const normalizedAddress = this.normalizeAddress(address);
  const account = await this.accountsRepository.findByAddress(normalizedAddress);
  const computedHash = bytesToHex(blake3(new Uint8Array(file.buffer))).toLowerCase();
  const storedHash = account.profileHashValue.toLowerCase();
  const verified = computedHash === storedHash;
  return { verified, computedHash, storedHash };
}
```
- 上传接口 `POST /api/accounts/:address/verify-hash`（`apps/bff/src/modules/accounts/accounts.controller.ts:41-74`）使用 `memoryStorage`，限制 15MB，与前端注册页一致。
- 失败时返回 `400`，前端在 R2 数据流中展示哈希差异。

## 4.5 Fullnode 事务兜底（新设计）
> 现网问题：仅依赖 Indexer GraphQL 会导致交易哈希/时间戳缺失。为满足数据流 10.2、10.4、10.5、10.7 中的“Fullnode 兜底”节点，需新增 Fullnode 客户端模块。

### 4.5.1 模块结构（规划）
| 组件 | Anchor（未来目标路径） | 说明 |
|------|------------------------|------|
| `FullnodeModule` | `apps/bff/src/modules/fullnode/fullnode.module.ts` | 提供 HttpModule + 配置注入 |
| `FullnodeClient` | `apps/bff/src/modules/fullnode/fullnode.client.ts` | 封装 REST `GET /v1/transactions/by_version/:version`、`/by_hash/:hash` |
| `TxnCacheService` | `apps/bff/src/modules/fullnode/txn-cache.service.ts` | LRU 缓存，避免高频调用 |
| `FullnodeSyncService` | `apps/bff/src/modules/fullnode/fullnode-sync.service.ts` | 提供 `resolveTxnMeta({version, hash?})` API 给 Listener 与 Timeline 使用 |

### 4.5.2 接入点
1. `AccountsEventListener.processEvent` 在写库前调用 `FullnodeSyncService.resolveTxnMeta`，若 Fullnode 返回 404 则记录补偿任务。
2. 未来 `OrdersEventListener`、`ClaimsEventListener` 共用该服务，确保时间线展示统一来源。
3. 对于失败重试，保存至 `fullnode_missing_transactions` 表（`apps/bff/prisma/schema.prisma` 需新增，未来补充）。

## 4.6 O1 — 订单草稿与签署（规划）
| 场景节点 | Anchor | 职责 |
|----------|--------|------|
| `OrdersDraftController` | `apps/bff/src/modules/orders/orders.controller.ts:1` | `POST /api/orders/drafts` 保存草稿、返回 `recordUid` 与签名载荷 |
| `OrdersService.createDraft` | `apps/bff/src/modules/orders/orders.service.ts:1` | 校验仓库/卖家注册状态、调用 Prisma 写入 `orders` 草稿表 |
| `OrdersEventListener` | `apps/bff/src/modules/orders/orders-event-listener.service.ts:1` | 监听 `OrderCreated` 等事件，结合 Fullnode 数据更新订单状态 |
| `OrdersTimelineRepository` | `apps/bff/src/modules/orders/orders.repository.ts:1` | 维护时间线、媒体引用，与 `MediaAsset` 表关联 |

- 所有订单相关 API 必须依赖新建的 `FullnodeSyncService` 获取事务哈希与时间戳，否则标记为“待补偿”。

## 4.7 O2 — 媒体上传与出库时间线
### 4.7.1 现有上传服务
```ts
// apps/bff/src/modules/media/media.service.ts:33-124
async handleUpload(file: Express.Multer.File | undefined, rawBody: RawUploadMediaBody) {
  if (!file) {
    throw new BadRequestException('Upload file is required');
  }
  const body = this.normalizeBody(rawBody);
  if (!body.recordUid) {
    throw new BadRequestException('record_uid is required');
  }
  const normalizedHashAlgorithm = this.normalizeHashAlgorithm(body.hashAlgorithm);
  if (body.hashAlgorithm && !normalizedHashAlgorithm) {
    throw new BadRequestException('Unsupported hash algorithm');
  }
  const normalizedStage = this.normalizeStage(body.stage);
  const normalizedCategory = body.category ? body.category.toLowerCase() : undefined;
  this.assertFileAllowed(file);
  const computedHash = this.computeBlake3(file.buffer);
  if (body.hashValue) {
    const normalizedExpected = this.normalizeHash(body.hashValue);
    if (computedHash !== normalizedExpected) {
      throw new BadRequestException({
        message: 'Hash mismatch between client and server',
        code: ORDER_MEDIA_ERROR_CODES.HASH_MISMATCH
      });
    }
  }
  const stored = await this.storage.save({
    buffer: file.buffer,
    originalName: file.originalname,
    mimeType: file.mimetype,
    recordUid: body.recordUid,
    stage: normalizedStage,
    category: normalizedCategory
  });
  const stage = normalizedStage ?? ORDER_MEDIA_STAGES.INBOUND;
  const category = normalizedCategory ?? this.resolveCategory(file.mimetype);
  const uploadedAt = new Date();
  await this.repository.recordUpload({
    recordUid: body.recordUid,
    stage,
    category,
    storagePath: stored.storagePath,
    publicPath: stored.publicPath,
    hashAlgo: ORDER_MEDIA_HASH_ALGORITHMS.BLAKE3,
    hashValue: computedHash,
    mimeType: file.mimetype,
    sizeBytes: file.size,
    uploadedBy: body.address,
    uploadedAt
  });
  return {
    recordUid: body.recordUid,
    stage,
    category,
    hashAlgorithm: normalizedHashAlgorithm ?? ORDER_MEDIA_HASH_ALGORITHMS.BLAKE3,
    hashValue: computedHash,
    crossCheckHashAlgorithm: body.crossCheckHashAlgorithm ? this.normalizeHashAlgorithm(body.crossCheckHashAlgorithm) : undefined,
    crossCheckHashValue: body.crossCheckHashValue ? this.normalizeHash(body.crossCheckHashValue) : undefined,
    sizeBytes: file.size,
    mimeType: file.mimetype,
    storagePath: stored.storagePath,
    path: stored.publicPath,
    uploadedBy: body.address,
    uploadedAt: uploadedAt.toISOString(),
    matchedOffchain: false,
    verificationStatus: ORDER_MEDIA_VERIFICATION_STATUSES.PENDING,
    hash: {
      algo: ORDER_MEDIA_HASH_ALGORITHMS.BLAKE3,
      value: computedHash
    }
  };
}
```
- 上传请求走 `POST /api/media/uploads`（`apps/bff/src/modules/media/media.controller.ts:24-55`），返回链下存证信息供前端缓存。
- 数据落地到 `MediaAsset` 表（`apps/bff/prisma/schema.prisma:34-55`），后续由订单时间线聚合。

### 4.7.2 出库监听（规划）
- `OrderFulfillmentListener` 将在 `apps/bff/src/modules/orders/orders-fulfilment-listener.service.ts`（未来目标路径）解析 `CheckedIn`、`SetInStorage`、`CheckedOut` 事件，写入 `order_events` 表。
- 需与 `MediaAsset` 进行哈希对账，若缺失则触发补偿队列。

## 4.8 C1 / S1 — 理赔与质押扩展（规划）
| 场景 | Anchor（未来目标路径） | 关键任务 |
|------|------------------------|----------|
| 理赔开启/结案 | `apps/bff/src/modules/claims/claims.controller.ts`、`claims.service.ts`、`claims-event-listener.service.ts` | 草稿保存、事件监听、赔付审批对接 Ops，使用 Fullnode 兜底事务 |
| 质押状态 & 信用榜 | `apps/bff/src/modules/staking/staking.controller.ts`、`staking-event-listener.service.ts`、`credit-score.service.ts` | 聚合 `StakeChanged` 事件、调用 Fullnode 查询余额、驱动信用评分任务 |

- 所有规划模块应复用 `TxnCacheService`，避免重复实现 Fullnode 调用。
- 与 Hasura/分析任务对接需在 `configuration` 中补充对应 URL 与密钥。

## 4.9 观测与补偿
- 监听器需记录 `transaction_version + event_index` 游标（`AccountsEventListener` 例子见 `apps/bff/src/modules/accounts/event-listener.service.ts:52-54`）。
- 当 Fullnode 请求失败时，将记录到补偿表并在后台任务中重试（新增 `apps/bff/src/modules/fullnode/fullnode-retry.task.ts`，未来目标路径）。
- 指标建议：
  1. Indexer 拉取延迟（事件时间戳 vs. BFF 处理时间）；
  2. Fullnode 重试次数；
  3. 上传哈希校验失败率；
  4. Prisma 写库耗时。

> **落地要求**：实现上述规划模块时，必须先在文档中补充对应 Anchor 与核心代码片段，再提交代码，确保链上/链下/前端三端语义保持一致。
